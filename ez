print("hi")
getgenv().Spoof = {
        ["Main"] = {
            ["Intro"] = true,
            ["UI"] = true,
            ["Keybind"] = "P",
            ["Visible Text"] = false
        },
        ["Triggerbot"] = {
            ["Enabled"] = false,
            ["Key"] = "T",
            ["Toggle"] = true,
            ["Hold"] = false,
            ["Delay"] = 0.1,
            ["Distance"] = 150,
            ["CheckTeam"] = false,
            ["CheckKnocked"] = true,
            ["VisibilityCheck"] = true
        },
        ["UITitle"] = {
            ["Text"] = "Spoofed",
            ["Extension"] = {
                ["Fringe"] = "[",
                ["End"] = "]"
            },
            ["Size"] = 13
        },
        ["Size"] = {
            ["X"] = 10 * 10,
            ["Y"] = 10 * 1
        },
        ["Color"] = {
            ["Inline"] = Color3.fromRGB(255,255,255),
            ["Outline"] = Color3.fromRGB(0, 0, 0)
        },
        ["Fade Speed"] = {
            ["Intro"] = 0.1,
            ["Outro"] = 0.01
        },
        ["Misc"] = {
            ["Check"] = {
                ["TeamCheck"] = false,
                ["PlayerKnockCheck"] = true,
                ["VisCheck"] = true,
                ["Resolver"] = false
            },
            ["FOV"] = {
                ["Esp"] = {
                    ["Enabled"] = true,
                    ["Keybind"] = "T",
                    ["Radius"] = 700,
                    ["Style"] = "Circle",
                    ["BoxSize"] = {
                        ["X"] = 500,
                        ["Y"] = 500
                    },
                    ["Inline"] = {
                        ["Transparency"] = 0.4,
                        ["Color"] = Color3.fromRGB(255, 255, 255)
                    },
                    ["Outline"] = {
                        ["Transparency"] = 0.65,
                        ["Color"] = Color3.fromRGB(255, 255, 255)
                    },
                    ["Control"] = {
                        ["Stick To Target"] = false,
                        ["ShowClosestPoint"] = true
                    }
                }
            }
        },
        ["Aimbot"] = {
            ["Panel"] = {
                ["Enabled"] = true,
                ["Keybind"] = {
                    ["Enabled"] = "F",
                    ["Disabled"] = "G"
                },
                Key = 'C',
                ["HitPart"] = {
                    ["Target"] = "HumanoidRootPart",
                    ["Revaluate"] = {
                        ["Enabled"] = false,
                        ["Origin"] = "Humanoid"
                    }
                },
                ["Prediction"] = {
                    ["Enabled"] = true,
                    ["Amount"] = 10
                },
                ["Assist"] = {
                    ["Enabled"] = true,
                    ["Amount"] = 40
                },
                ["Panel"] = {
                    ["Method"] = "Camera",
                    ["Target"] = false,
                    ["Lerp"] = {
                        ["Type"] = "Linear",
                        ["Direction"] = "In"
                    }
                }
            }
        },
        ["Silent"] = {
            ["Redirection"] = {
                ["Info"] = {
                    ["Enabled"] = true,
                    ["Keybind"] = "E"
                },
                ["Extension"] = {
                    ["Fringe"] = "[",
                    ["End"] = "]"
                },
                ["HitPart"] = {
                    ["Target"] = "Head",
                    ["Revaluate"] = {
                        ["Enabled"] = true,
                        ["Origin"] = "Humanoid"
                    },
                    ["Validated Part"] = {"HumanoidRootPart", "Head"}
                },
                ["HitChance"] = {
                    ["Enabled"] = true,
                    ["Amount"] = 100
                },
                ["Prediction"] = {
                    ["Enabled"] = true,
                    ["Amount"] = 0
                }, 
                ["AntiCurve"] = {
                    ["Enabled"] = true,
                    ["X"] = 0,
                    ["Y"] = 0,
                    ["Z"] = 0
                },
                ["Visualizetarget"] = {
                    ["Enabled"] = true,
                    ["Tracer"] = {
                        ["Enabled"] = true,
                        ["Key"] = "Y",
                        ["Color"] = Color3.fromRGB(255, 255, 255),
                        ["Thickness"] = 1,
                        ["Transparency"] = 1
                    }
                }
            }
        },
        ["WalkSpeed"] = {
            ["Options"] = {
                ["Enabled"] = true,
                ["Speed"] = 325,
                ["Keybind"] = "V",
                ["AutoEmote"] = false,
                ["EmoteDelay"] = 0.15,
                ["EmoteKey"] = "Period",
                ["EmoteSlot"] = "1"
            }
        },
        ["Camlock"] = {
            ["Enabled"] = false,
            ["Key"] = "Q",
            ["Toggle"] = true,
            ["Prediction"] = {
                ["Enabled"] = true,
                ["Amount"] = 0.135
            },
            ["Smoothness"] = {
                ["Enabled"] = true,
                ["Amount"] = 0.055
            },
            ["HitPart"] = "HumanoidRootPart",
            ["Shake"] = {
                ["Enabled"] = true,
                ["X"] = 3,
                ["Y"] = 3,
                ["Z"] = 3
            },
            ["AimAssist"] = {
                ["Enabled"] = true,
                ["Strength"] = 0.35,
                ["SlowSensitivity"] = true,
                ["SlowAmount"] = 0.5
            }
        },
    }
    if not LPH_OBFUSCATED then
        LPH_JIT_MAX = function(...)
            return (...)
        end
        LPH_JIT_ULTRA = function(...)
            return (...)
        end
    end


    LPH_JIT_MAX(
        function()
            local Drawing, FromRGB = Drawing.new, Color3.fromRGB
            local UIS, Players, MPS, RunService, Camera, Tween =
                game:GetService("UserInputService"),
                game:GetService("Players"),
                game:GetService("MarketplaceService"),
                game:GetService("RunService"),
                game:GetService("Workspace").CurrentCamera,
                {}
            function Direction(Value, Two)
                return Vector2.new(Value / Spoof["Size"].X, Two / Spoof["Size"].Y)
            end
            local cam = workspace.CurrentCamera
            local x = cam.ViewportSize.X
            local y = cam.ViewportSize.Y
            local newx = math.floor(x * 0.51)
            local newy = math.floor(y * 0.44)
            local Title = Drawing("Text")
            local Value = Drawing("Text")
            local Part = Drawing("Text")
            if Spoof["Main"]["Intro"] == true then
                -- Create the intro GUI
                local Intro = Instance.new("ScreenGui")
                Intro.Name = "QuietIntro"
                Intro.Parent = game.CoreGui
                
                -- Create background frame
                local Background = Instance.new("Frame")
                Background.Size = UDim2.new(1, 0, 1, 0)
                Background.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
                Background.BackgroundTransparency = 0
                Background.Parent = Intro
                
                -- Create stick figures container
                local StickFigures = Instance.new("Frame")
                StickFigures.Size = UDim2.new(0.4, 0, 0.4, 0)
                StickFigures.Position = UDim2.new(0.3, 0, 0.3, 0)
                StickFigures.BackgroundTransparency = 1
                StickFigures.Parent = Background
                
                -- Function to create a stick figure
                local function CreateStickFigure(position, color)
                    local container = Instance.new("Frame")
                    container.Size = UDim2.new(0.15, 0, 0.4, 0)
                    container.Position = position
                    container.BackgroundTransparency = 1
                    container.Parent = StickFigures

                    -- Head
                    local head = Instance.new("Frame")
                    head.Size = UDim2.new(0.2, 0, 0.2, 0)
                    head.Position = UDim2.new(0.4, 0, 0, 0)
                    head.BackgroundColor3 = color
                    head.Parent = container

                    -- Body
                    local body = Instance.new("Frame")
                    body.Size = UDim2.new(0.1, 0, 0.4, 0)
                    body.Position = UDim2.new(0.45, 0, 0.2, 0)
                    body.BackgroundColor3 = color
                    body.Parent = container

                    -- Arms
                    local leftArm = Instance.new("Frame")
                    leftArm.Size = UDim2.new(0.3, 0, 0.1, 0)
                    leftArm.Position = UDim2.new(0.15, 0, 0.25, 0)
                    leftArm.BackgroundColor3 = color
                    leftArm.Parent = container

                    local rightArm = Instance.new("Frame")
                    rightArm.Size = UDim2.new(0.3, 0, 0.1, 0)
                    rightArm.Position = UDim2.new(0.55, 0, 0.25, 0)
                    rightArm.BackgroundColor3 = color
                    rightArm.Parent = container

                    -- Legs
                    local leftLeg = Instance.new("Frame")
                    leftLeg.Size = UDim2.new(0.1, 0, 0.3, 0)
                    leftLeg.Position = UDim2.new(0.35, 0, 0.6, 0)
                    leftLeg.BackgroundColor3 = color
                    leftLeg.Parent = container

                    local rightLeg = Instance.new("Frame")
                    rightLeg.Size = UDim2.new(0.1, 0, 0.3, 0)
                    rightLeg.Position = UDim2.new(0.55, 0, 0.6, 0)
                    rightLeg.BackgroundColor3 = color
                    rightLeg.Parent = container

                    return container
                end

                -- Create stick figures
                local StickFigure1 = CreateStickFigure(UDim2.new(0.1, 0, 0.3, 0), Color3.fromRGB(255,255,255))
                local StickFigure2 = CreateStickFigure(UDim2.new(0.6, 0, 0.3, 0), Color3.fromRGB(255, 255, 255))

                -- Add weapon effects
                local function CreateWeaponEffect(parent, side)
                    local weapon = Instance.new("Frame")
                    weapon.Size = UDim2.new(0.4, 0, 0.05, 0)
                    weapon.Position = UDim2.new(side == "left" and -0.2 or 0.8, 0, 0.25, 0)
                    weapon.BackgroundColor3 = Color3.fromRGB(255, 0, 0)
                    weapon.Parent = parent
                    return weapon
                end

                local weapon1 = CreateWeaponEffect(StickFigure1, "right")
                local weapon2 = CreateWeaponEffect(StickFigure2, "left")

                -- Add glow effects
                local function CreateGlow(parent)
                    local glow = Instance.new("ImageLabel")
                    glow.Size = UDim2.new(2, 0, 2, 0)
                    glow.Position = UDim2.new(-0.5, 0, -0.5, 0)
                    glow.BackgroundTransparency = 1
                    glow.Image = "rbxassetid://131274595"
                    glow.ImageColor3 = parent.BackgroundColor3
                    glow.ImageTransparency = 0.8
                    glow.Parent = parent
                    return glow
                end

                -- Add glows to weapons
                CreateGlow(weapon1)
                CreateGlow(weapon2)
                
                -- Create logo text
                local LogoText = Instance.new("TextLabel")
                LogoText.Size = UDim2.new(0.5, 0, 0.1, 0)
                LogoText.Position = UDim2.new(0.25, 0, 0.8, 0)
                LogoText.BackgroundTransparency = 1
                LogoText.Text = "SpoofED KILLS YOU"
                LogoText.TextColor3 = Color3.fromRGB(255,255,255)
                LogoText.TextSize = 48
                LogoText.Font = Enum.Font.GothamBold
                LogoText.Parent = Background
                
                -- Create discord text
                local DiscordText = Instance.new("TextLabel")
                DiscordText.Size = UDim2.new(0.5, 0, 0.05, 0)
                DiscordText.Position = UDim2.new(0.25, 0, 0.9, 0)
                DiscordText.BackgroundTransparency = 1
                DiscordText.Text = "discord.gg/Spoofedlol"
                DiscordText.TextColor3 = Color3.fromRGB(255, 255, 255)
                DiscordText.TextSize = 24
                DiscordText.Font = Enum.Font.Gotham
                DiscordText.Parent = Background
                DiscordText.TextTransparency = 1
                
                -- Play roar sound
                local RoarSound = Instance.new("Sound")
                RoarSound.SoundId = "rbxassetid://6545997667" -- Epic roar sound
                RoarSound.Volume = 0.5
                RoarSound.Parent = game.CoreGui
                RoarSound:Play()
                
                -- Animate stick figures
                local TweenService = game:GetService("TweenService")
                
                -- Create hit effect
                local function CreateHitEffect(position)
                    local effect = Instance.new("ImageLabel")
                    effect.Size = UDim2.new(0.2, 0, 0.2, 0)
                    effect.Position = position
                    effect.BackgroundTransparency = 1
                    effect.Image = "rbxassetid://446111271"  -- Explosion effect
                    effect.ImageColor3 = Color3.fromRGB(255, 0, 0)
                    effect.ImageTransparency = 0
                    effect.Parent = Background
                    
                    -- Animate the hit effect
                    TweenService:Create(effect, TweenInfo.new(0.3), {
                        Size = UDim2.new(0.4, 0, 0.4, 0),
                        ImageTransparency = 1
                    }):Play()
                    
                    task.delay(0.3, function()
                        effect:Destroy()
                    end)
                end

                -- Fight animation sequence
                task.spawn(function()
                    -- Initial pause
                    task.wait(0.5)

                    for i = 1, 2 do
                        -- Figure 1 attack sequence
                        TweenService:Create(StickFigure1, TweenInfo.new(0.2), {
                            Position = UDim2.new(0.3, 0, 0.3, 0),
                            Rotation = 15
                        }):Play()
                        
                        task.wait(0.1)
                        CreateHitEffect(UDim2.new(0.45, 0, 0.4, 0))
                        
                        -- Weapon flash effect
                        TweenService:Create(weapon1, TweenInfo.new(0.1), {
                            BackgroundColor3 = Color3.fromRGB(255, 255, 0)
                        }):Play()
                        
                        task.wait(0.1)
                        TweenService:Create(StickFigure1, TweenInfo.new(0.2), {
                            Position = UDim2.new(0.1, 0, 0.3, 0),
                            Rotation = 0
                        }):Play()
                        
                        TweenService:Create(weapon1, TweenInfo.new(0.1), {
                            BackgroundColor3 = Color3.fromRGB(255, 0, 0)
                        }):Play()

                        -- Figure 2 attack sequence
                        task.wait(0.3)
                        TweenService:Create(StickFigure2, TweenInfo.new(0.2), {
                            Position = UDim2.new(0.4, 0, 0.3, 0),
                            Rotation = -15
                        }):Play()
                        
                        task.wait(0.1)
                        CreateHitEffect(UDim2.new(0.25, 0, 0.4, 0))
                        
                        -- Weapon flash effect
                        TweenService:Create(weapon2, TweenInfo.new(0.1), {
                            BackgroundColor3 = Color3.fromRGB(255, 255, 0)
                        }):Play()
                        
                        task.wait(0.1)
                        TweenService:Create(StickFigure2, TweenInfo.new(0.2), {
                            Position = UDim2.new(0.6, 0, 0.3, 0),
                            Rotation = 0
                        }):Play()
                        
                        TweenService:Create(weapon2, TweenInfo.new(0.1), {
                            BackgroundColor3 = Color3.fromRGB(255, 0, 0)
                        }):Play()
                        
                        task.wait(0.3)
                    end

                    -- Final clash
                    TweenService:Create(StickFigure1, TweenInfo.new(0.3), {
                        Position = UDim2.new(0.35, 0, 0.3, 0),
                        Rotation = 30
                    }):Play()
                    
                    TweenService:Create(StickFigure2, TweenInfo.new(0.3), {
                        Position = UDim2.new(0.35, 0, 0.3, 0),
                        Rotation = -30
                    }):Play()
                    
                    task.wait(0.3)
                    CreateHitEffect(UDim2.new(0.35, 0, 0.4, 0))
                    
                    -- Big flash effect
                    local flash = Instance.new("Frame")
                    flash.Size = UDim2.new(1, 0, 1, 0)
                    flash.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
                    flash.BackgroundTransparency = 0
                    flash.Parent = Background
                    
                    TweenService:Create(flash, TweenInfo.new(0.5), {
                        BackgroundTransparency = 1
                    }):Play()
                    
                    task.wait(0.5)
                    flash:Destroy()
                end)
                
                -- Fade in logo and discord text
                task.wait(0.5)
                TweenService:Create(LogoText, TweenInfo.new(0.5), {TextTransparency = 0}):Play()
                task.wait(0.3)
                TweenService:Create(DiscordText, TweenInfo.new(0.5), {TextTransparency = 0}):Play()
                
                -- Hold the animation
                task.wait(2)
                
                -- Fade out everything
                TweenService:Create(Background, TweenInfo.new(0.5), {BackgroundTransparency = 1}):Play()
                TweenService:Create(StickFigure1, TweenInfo.new(0.5), {BackgroundTransparency = 1}):Play()
                TweenService:Create(StickFigure2, TweenInfo.new(0.5), {BackgroundTransparency = 1}):Play()
                TweenService:Create(LogoText, TweenInfo.new(0.5), {TextTransparency = 1}):Play()
                TweenService:Create(DiscordText, TweenInfo.new(0.5), {TextTransparency = 1}):Play()
                
                -- Clean up
                task.wait(0.5)
                Intro:Destroy()
                RoarSound:Destroy()
            end
            wait(0.15)

            local function Table()
                local hitparts = Spoof.Silent.Redirection["HitPart"]["Validated Parts"]

                Title.Position, Title.Size =
                    Direction(Camera.ViewportSize.X + 800, Camera.ViewportSize.Y),
                    Spoof["UITitle"].Size
                Value.Position, Value.Size =
                    Direction(Camera.ViewportSize.X, Camera.ViewportSize.Y + 400),
                    Spoof["UITitle"].Size
                Part.Position, Part.Size =
                    Direction(Camera.ViewportSize.X + 800, Camera.ViewportSize.Y + 600),
                    Spoof["UITitle"].Size

                if Spoof["Main"]["UI"] then
                    Title.Text, Title.Font =
                        tostring(
                            Spoof["UITitle"].Text ..
                                " " ..
                                    Spoof["UITitle"].Extension.Fringe ..
                                        game.Stats.Workspace.Heartbeat:GetValueString() .. Spoof["UITitle"].Extension.End
                        ),
                        2
                    Title.Visible, Title.Outline, Title.Color, Title.OutlineColor =
                        Spoof["Main"]["Visible Text"],
                        true,
                        Spoof["Color"].Inline,
                        Spoof["Color"].Outline

                    Value.Font, Value.Visible, Value.Inline, Value.Color, Value.OutlineColor =
                        2,
                        Spoof["Main"]["Visible Text"],
                        true,
                        Spoof.Silent.Redirection,
                        Spoof["Color"].Inline

                    Part.Font, Part.Visible, Part.Inline, Part.Color, Part.OutlineColor =
                        2,
                        Spoof["Main"]["Visible Text"],
                        true,
                        Spoof.Silent.Redirection,
                        Spoof["Color"].Inline

                    if Spoof.Silent.Redirection["Info"].Enabled then
                        Value.Text = "   " .. "Silent" .. " = " .. "On"
                        Part.Text = tostring("HitPart" .." = " .. (Spoof.Silent["Redirection"]["HitPart"]["Target"]):lower())
                        
                        if isSpeedEnabled and enable then
                            Part.Text = Part.Text .. "\n   Speed = " .. tostring(getgenv().Spoof.WalkSpeed.Options.DefaultSpeed)
                        end
                    else
                        Part.Text = ""
                        Value.Text = "   " .. "Silent" .. " = " .. "Off"
                        
                        if isSpeedEnabled and enable then
                            Part.Text = "   Speed = " .. tostring(getgenv().Spoof.WalkSpeed.Options.DefaultSpeed)
                        end
                    end
                else
                end
            end

            local Utilitie = {}
            Utilitie.Toggle = false

            UIS.InputBegan:Connect(
                function(Two, Input)
                    if not Input then
                        if Two.KeyCode.Name == Spoof["Main"]["Keybind"] then
                            Utilitie.Toggle = not Utilitie.Toggle
                            if Utilitie.Toggle then
                                RunService:BindToRenderStep("Table!", 1, Table)
                                for i = 0, 1, Spoof["Fade Speed"].Intro do
                                    wait(0)
                                    Title.Transparency = i
                                    Value.Transparency = i
                                    Part.Transparency = i
                                end

                                Spoof["Main"]["UI"] = true
                                Spoof["Main"]["Visible Text"] = true
                            elseif not Utilitie.Toggle then
                                RunService:UnbindFromRenderStep("Table")
                                Spoof["Main"]["UI"] = false

                                Title.Transparency = 0.9
                                Value.Transparency = 0.9
                                Part.Transparency = 0.9
                                wait(Spoof["Fade Speed"].Outro)
                                Title.Transparency = 0.8
                                Value.Transparency = 0.8
                                Part.Transparency = 0.8
                                wait(Spoof["Fade Speed"].Outro)
                                Title.Transparency = 0.7
                                Value.Transparency = 0.7
                                Part.Transparency = 0.7
                                wait(Spoof["Fade Speed"].Outro)
                                Title.Transparency = 0.6
                                Value.Transparency = 0.6
                                Part.Transparency = 0.6
                                wait(Spoof["Fade Speed"].Outro)
                                Title.Transparency = 0.5
                                Value.Transparency = 0.5
                                Part.Transparency = 0.5
                                wait(Spoof["Fade Speed"].Outro)
                                Title.Transparency = 0.4
                                Value.Transparency = 0.4
                                Part.Transparency = 0.4
                                wait(Spoof["Fade Speed"].Outro)
                                Title.Transparency = 0.3
                                Value.Transparency = 0.3
                                Part.Transparency = 0.3
                                wait(Spoof["Fade Speed"].Outro)
                                Title.Transparency = 0.2
                                Value.Transparency = 0.2
                                Part.Transparency = 0.2
                                wait(Spoof["Fade Speed"].Outro)
                                Title.Transparency = 0.1
                                Value.Transparency = 0.1
                                Part.Transparency = 0.1
                                wait(Spoof["Fade Speed"].Outro)
                                Title.Transparency = 0.1
                                Value.Transparency = 0.1
                                Part.Transparency = 0.1
                                wait(Spoof["Fade Speed"].Outro)

                                Title.Transparency = 0
                                Value.Transparency = 0
                                Part.Transparency = 0
                            end
                        end
                    end
                end
            )

            WTS = (function(Object)
                local ObjectVector = Camera:WorldToScreenPoint(Object.Position)
                return Vector2.new(ObjectVector.X, ObjectVector.Y)
            end)

            local FOV = {}
            FOV.MouseLink = Drawing("Circle")
            FOV.ClosestPoint = Drawing("Circle")
            FOV.Line = Drawing("Line")
            FOV.LineOutline = Drawing("Line")
            
            -- Create both circle and box FOV elements
            FOV.Circle = {
                Outline = Drawing("Circle"),
                Inline = Drawing("Circle")
            }
            
            FOV.Box = {
                Outline = Drawing("Square"),
                Inline = Drawing("Square")
            }
            
            -- Initialize Line objects
            FOV.Line.Thickness = 3
            FOV.Line.Transparency = 0.8
            FOV.Line.Color = Color3.fromRGB(255, 255, 255)
            FOV.Line.Visible = false

            FOV.LineOutline.Thickness = 7
            FOV.LineOutline.Transparency = 0.4
            FOV.LineOutline.Color = Color3.fromRGB(255, 255, 255)
            FOV.LineOutline.Visible = false
            
            -- Initialize closest point indicator
            FOV.ClosestPoint.Radius = 4
            FOV.ClosestPoint.Filled = true
            FOV.ClosestPoint.Transparency = 1
            FOV.ClosestPoint.Color = Color3.fromRGB(255, 0, 0)
            FOV.ClosestPoint.Visible = false

            -- Initialize MouseLink
            FOV.MouseLink.Radius = 20
            FOV.MouseLink.Thickness = 0.4
            FOV.MouseLink.Filled = false
            FOV.MouseLink.Transparency = 1
            FOV.MouseLink.Color = Color3.fromRGB(255, 255, 255)
            FOV.MouseLink.Visible = false

            -- Initialize Circle FOV
            FOV.Circle.Inline.Visible = false
            FOV.Circle.Inline.Radius = Spoof.Misc.FOV.Esp.Radius
            FOV.Circle.Inline.Transparency = Spoof.Misc.FOV.Esp.Inline.Transparency
            FOV.Circle.Inline.Color = Spoof.Misc.FOV.Esp.Inline.Color
            FOV.Circle.Inline.Thickness = 3
            FOV.Circle.Inline.Filled = true

            FOV.Circle.Outline.Visible = false
            FOV.Circle.Outline.Radius = Spoof.Misc.FOV.Esp.Radius
            FOV.Circle.Outline.Transparency = Spoof.Misc.FOV.Esp.Outline.Transparency
            FOV.Circle.Outline.Color = Spoof.Misc.FOV.Esp.Outline.Color
            FOV.Circle.Outline.Thickness = 4
            FOV.Circle.Outline.Filled = false

            -- Initialize Box FOV
            FOV.Box.Inline.Visible = false
            FOV.Box.Inline.Size = Vector2.new(Spoof.Misc.FOV.Esp.BoxSize.X, Spoof.Misc.FOV.Esp.BoxSize.Y)
            FOV.Box.Inline.Transparency = Spoof.Misc.FOV.Esp.Inline.Transparency
            FOV.Box.Inline.Color = Spoof.Misc.FOV.Esp.Inline.Color
            FOV.Box.Inline.Thickness = 3
            FOV.Box.Inline.Filled = true

            FOV.Box.Outline.Visible = false
            FOV.Box.Outline.Size = Vector2.new(Spoof.Misc.FOV.Esp.BoxSize.X, Spoof.Misc.FOV.Esp.BoxSize.Y)
            FOV.Box.Outline.Transparency = Spoof.Misc.FOV.Esp.Outline.Transparency
            FOV.Box.Outline.Color = Spoof.Misc.FOV.Esp.Outline.Color
            FOV.Box.Outline.Thickness = 4
            FOV.Box.Outline.Filled = false

            -- Function to update FOV position
            local function UpdateFOVPosition(position)
                if Spoof.Misc.FOV.Esp.Style == "Circle" then
                    FOV.Circle.Inline.Position = position
                    FOV.Circle.Outline.Position = position
                    FOV.Circle.Inline.Visible = Spoof.Misc.FOV.Esp.Enabled
                    FOV.Circle.Outline.Visible = Spoof.Misc.FOV.Esp.Enabled
                    FOV.Box.Inline.Visible = false
                    FOV.Box.Outline.Visible = false
                else
                    FOV.Box.Inline.Position = position - (FOV.Box.Inline.Size / 2)
                    FOV.Box.Outline.Position = position - (FOV.Box.Outline.Size / 2)
                    FOV.Box.Inline.Visible = Spoof.Misc.FOV.Esp.Enabled
                    FOV.Box.Outline.Visible = Spoof.Misc.FOV.Esp.Enabled
                    FOV.Circle.Inline.Visible = false
                    FOV.Circle.Outline.Visible = false
                end
            end

            -- Function to get closest point on FOV
            local function GetClosestPointOnFOV(center, target)
                if Spoof.Misc.FOV.Esp.Style == "Circle" then
                    local direction = (target - center).Unit
                    return center + direction * FOV.Circle.Inline.Radius
                else
                    local halfSize = FOV.Box.Inline.Size / 2
                    local relative = target - center
                    local clamped = Vector2.new(
                        math.clamp(relative.X, -halfSize.X, halfSize.X),
                        math.clamp(relative.Y, -halfSize.Y, halfSize.Y)
                    )
                    return center + clamped
                end
            end

            local GameInfo = game.PlaceId

            local LocalPlayer = Players.LocalPlayer
            local Mouse = LocalPlayer:GetMouse()

            local IgnoreList = {LocalPlayer.Character, Camera}
            local StickyTarget = nil  -- Add sticky target variable

            local function PartVisible(Part)
                if Spoof.Misc.Check["VisCheck"] and Part and Part.Head then
                    local Hit =
                        workspace:FindPartOnRayWithIgnoreList(
                        Ray.new(Camera.CFrame.Position, Part.Head.Position - Camera.CFrame.Position),
                        IgnoreList
                    )
                    if Hit and Hit:IsDescendantOf(Part) then
                        return true
                    end
                    return false
                else
                    return true
                end
            end

            function ClosestToCursor()
                -- If we have a valid sticky target, keep using it
                if StickyTarget and StickyTarget.Character and StickyTarget.Character:FindFirstChild("HumanoidRootPart") and
                    (Spoof.Misc["Check"]["TeamCheck"] == true and (StickyTarget.Team ~= LocalPlayer.Team) or
                        Spoof.Misc["Check"]["TeamCheck"] ~= true)
                then
                    local MouseLocation = UIS:GetMouseLocation()
                    local Vector, IsVisible = Camera:WorldToViewportPoint(StickyTarget.Character.HumanoidRootPart.Position)
                    
                    -- Only check if target is still visible and valid
                    if IsVisible and PartVisible(StickyTarget.Character) then
                        return StickyTarget
                    end
                end

                -- Only find new target if we don't have a sticky target
                if not StickyTarget then
                local Closest = nil
                    local Distance = FOV.Circle.Inline.Radius
                for i, v in pairs(Players:GetPlayers()) do
                    if v ~= LocalPlayer and v.Character and v.Character:FindFirstChild("HumanoidRootPart") and
                        (Spoof.Misc["Check"]["TeamCheck"] == true and (v.Team ~= LocalPlayer.Team) or
                            Spoof.Misc["Check"]["TeamCheck"] ~= true)
                    then
                        local MouseLocation = UIS:GetMouseLocation()
                        local Vector, IsVisible = Camera:WorldToViewportPoint(v.Character.HumanoidRootPart.Position)
                        local Magnitude = (Vector2.new(Vector.X, Vector.Y) - Vector2.new(MouseLocation.X, MouseLocation.Y)).magnitude

                        if Magnitude < Distance and IsVisible and PartVisible(v.Character) then
                            Closest = v
                            Distance = Magnitude
                        end
                    end
                end

                if GameInfo == 2788229376 and Spoof.Misc["Check"]["PlayerKnockCheck"] then
                    if Closest and Closest.Character and not Closest.Character:FindFirstChild("GRABBING_CONSTRAINT") and
                            not Closest.Character:FindFirstChild("BodyEffects")["K.O"].Value
                    then
                            StickyTarget = Closest
                        return Closest
                    end
                    return nil
                end
                
                if GameInfo ~= 2788229376 and Spoof.Misc["Check"]["PlayerKnockCheck"] then
                    if Closest and Closest.Character and Closest.Character.Humanoid.Health > 0 then
                            StickyTarget = Closest
                        return Closest
                    end
                    return nil
                end

                    StickyTarget = Closest
                return Closest
                end
                
                return nil
            end

            local player = game:GetService("Players").LocalPlayer
            local runService = game:GetService("RunService")
            local defaultSpeed = 16
            local isSpeedEnabled = false

            -- Main speed update function
            local function updateSpeed()
                if player.Character and player.Character:FindFirstChild("Humanoid") then
                    if isSpeedEnabled and Spoof.WalkSpeed.Options.Enabled then
                        player.Character.Humanoid.WalkSpeed = Spoof.WalkSpeed.Options.Speed
                        print("6443534534534:", Spoof.WalkSpeed.Options.Speed)
                    end
                end
            end

            -- Connect to RenderStepped for continuous updates
            local speedConnection = runService.RenderStepped:Connect(updateSpeed)

            -- Handle character respawning
            player.CharacterAdded:Connect(function(character)
                -- Wait for Humanoid to be available
                character:WaitForChild("Humanoid")
                -- Update speed immediately after respawn
                updateSpeed()
            end)

            -- Handle keybind toggle
            UIS.InputBegan:Connect(function(input, gameProcessed)
                if not gameProcessed and input.KeyCode.Name == Spoof.WalkSpeed.Options.Keybind then
                    isSpeedEnabled = not isSpeedEnabled
                    print("x14512:", isSpeedEnabled)
                    
                    if isSpeedEnabled then
                        print("2342323:", Spoof.WalkSpeed.Options.Speed)
                        player.Character.Humanoid.WalkSpeed = Spoof.WalkSpeed.Options.Speed
                        
                        -- Trigger emote when enabling walkspeed
                        if Spoof.WalkSpeed.Options.AutoEmote then
                            local VirtualInputManager = game:GetService("VirtualInputManager")
                            
                            -- Send emote key
                            VirtualInputManager:SendKeyEvent(true, Enum.KeyCode[Spoof.WalkSpeed.Options.EmoteKey], false, game)
                            task.wait(Spoof.WalkSpeed.Options.EmoteDelay)
                            VirtualInputManager:SendKeyEvent(false, Enum.KeyCode[Spoof.WalkSpeed.Options.EmoteKey], false, game)
                            
                            -- Select emote slot
                            task.wait(Spoof.WalkSpeed.Options.EmoteDelay)
                            VirtualInputManager:SendKeyEvent(true, Enum.KeyCode[Spoof.WalkSpeed.Options.EmoteSlot], false, game)
                            task.wait(Spoof.WalkSpeed.Options.EmoteDelay)
                            VirtualInputManager:SendKeyEvent(false, Enum.KeyCode[Spoof.WalkSpeed.Options.EmoteSlot], false, game)
                        end
                    else
                        print("xdef")
                        player.Character.Humanoid.WalkSpeed = defaultSpeed
                    end
                end
            end)

            -- Add toggle handler for silent aim
            UIS.InputBegan:Connect(function(input, gameProcessed)
                if not gameProcessed and input.KeyCode.Name == Spoof.Silent.Redirection.Info.Keybind then
                    -- Toggle sticky target on/off
                    if StickyTarget then
                        StickyTarget = nil
                    else
                        -- Find new target when toggling on
                        local MouseLocation = UIS:GetMouseLocation()
                        local Closest = nil
                        local Distance = FOV.Circle.Inline.Radius
                        
                        for i, v in pairs(Players:GetPlayers()) do
                            if v ~= LocalPlayer and v.Character and v.Character:FindFirstChild("HumanoidRootPart") then
                                local Vector, IsVisible = Camera:WorldToViewportPoint(v.Character.HumanoidRootPart.Position)
                                local Magnitude = (Vector2.new(Vector.X, Vector.Y) - Vector2.new(MouseLocation.X, MouseLocation.Y)).magnitude

                                if Magnitude < Distance and IsVisible and PartVisible(v.Character) then
                                    Closest = v
                                    Distance = Magnitude
                                end
                            end
                        end
                        
                        if Closest then
                            StickyTarget = Closest
                        end
                    end
                end
            end)

            local Meta = getrawmetatable(game)
            local backupindex = Meta.__index
            setreadonly(Meta, false)

            Meta.__index = function(t, k)
                if k:lower() == "hit" and Spoof.Silent.Redirection.Info.Enabled then
                    local TargetPlayer = ClosestToCursor()
                    
                    if TargetPlayer and TargetPlayer.Character then
                        -- Check hit chance
                        local Chance = not Spoof.Silent.Redirection.HitChance.Enabled or 
                                    (Spoof.Silent.Redirection.HitChance.Amount >= math.random(1, 100))
                        
                        if not Chance then
                            return backupindex(t, k)
                        end

                        -- Get target part and validate
                        local Part = TargetPlayer.Character:FindFirstChild(Spoof.Silent["Redirection"]["HitPart"].Target)
                        if not Part then
                            -- Fallback to validated parts if primary target not found
                            for _, validPart in ipairs(Spoof.Silent.Redirection["HitPart"]["Validated Part"]) do
                                Part = TargetPlayer.Character:FindFirstChild(validPart)
                                if Part then break end
                            end
                        end

                        if Part then
                            -- Apply anti-curve to bullet trajectory
                            if Spoof.Silent.Redirection.AntiCurve.Enabled then
                                local AntiCurve = CFrame.Angles(
                                    math.rad(Spoof.Silent.Redirection.AntiCurve.X),
                                    math.rad(Spoof.Silent.Redirection.AntiCurve.Y),
                                    math.rad(Spoof.Silent.Redirection.AntiCurve.Z)
                                )
                                
                                -- Get the direction from camera to target
                                local Direction = (Part.Position - Camera.CFrame.Position).Unit
                                
                                -- Apply anti-curve rotation to the direction
                                Direction = AntiCurve:VectorToWorldSpace(Direction)
                                
                                -- Create a new CFrame at the target position with the adjusted direction
                                return CFrame.new(Part.Position) * CFrame.fromMatrix(Vector3.new(), Direction:Cross(Vector3.new(0, 1, 0)), Vector3.new(0, 1, 0), Direction)
                            else
                                -- Return the part's CFrame directly if anti-curve is disabled
                            return Part.CFrame
                            end
                        end
                    end
                end
                return backupindex(t, k)
            end

            LocalPlayer.Chatted:Connect(
                function(message)
                    if Spoof.ChatCommands.Enabled then
                        local args = string.split(message, " ")
                        if args[1] == Spoof.ChatCommands.Fov and args[2] ~= nil then
                            Spoof.Misc.FOV.Esp.Radius = tonumber(args[2])
                        end

                        if Spoof.ChatCommands.Enabled then
                            local args = string.split(message, " ")
                            if args[1] == Spoof.ChatCommands.Prediction and args[2] ~= nil then
                                Spoof.Silent.Redirection.Prediction.Amount = tonumber(args[2])
                            end
                        end
                    end
                end
            )


            local MouseLoop =
                RunService.Heartbeat:Connect(
                function()
                    local MouseLocation = UIS:GetMouseLocation()

                    -- Only use StickyTarget for visualization
                    if Spoof.Misc.FOV["Esp"]["Control"]["Stick To Target"] and StickyTarget and StickyTarget.Character then
                        local Root = StickyTarget.Character[Spoof.Silent["Redirection"]["HitPart"].Target]
                        local RootToViewportPoint, IsVisible = Camera.WorldToViewportPoint(Camera, Root.Position)

                        UpdateFOVPosition(Vector2.new(RootToViewportPoint.X, RootToViewportPoint.Y))
                    else
                        UpdateFOVPosition(Vector2.new(MouseLocation.X, MouseLocation.Y))
                    end

                    -- Update closest point visualization only for sticky target
                    if Spoof.Misc.FOV.Esp.Control.ShowClosestPoint and StickyTarget and StickyTarget.Character then
                        local Root = StickyTarget.Character[Spoof.Silent["Redirection"]["HitPart"].Target]
                        local RootToViewportPoint, IsVisible = Camera.WorldToViewportPoint(Camera, Root.Position)
                        local TargetPos = Vector2.new(RootToViewportPoint.X, RootToViewportPoint.Y)
                        local ClosestPoint = GetClosestPointOnFOV(MouseLocation, TargetPos)
                        
                        FOV.ClosestPoint.Position = ClosestPoint
                        FOV.ClosestPoint.Visible = IsVisible and Spoof.Misc.FOV.Esp.Enabled
                    else
                        FOV.ClosestPoint.Visible = false
                    end

                    -- Tracer Line Logic - only for sticky target
                    if Spoof.Silent.Redirection.Info.Enabled and Spoof.Silent.Redirection.Visualizetarget.Tracer.Enabled and StickyTarget and StickyTarget.Character then
                        local Root = StickyTarget.Character[Spoof.Silent["Redirection"]["HitPart"].Target]
                        local RootToViewportPoint, IsVisible = Camera.WorldToViewportPoint(Camera, Root.Position)
                        
                        FOV.Line.From = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y)
                        FOV.Line.To = Vector2.new(RootToViewportPoint.X, RootToViewportPoint.Y)
                        FOV.Line.Color = Spoof.Silent.Redirection.Visualizetarget.Tracer.Color
                        FOV.Line.Thickness = Spoof.Silent.Redirection.Visualizetarget.Tracer.Thickness
                        FOV.Line.Transparency = Spoof.Silent.Redirection.Visualizetarget.Tracer.Transparency
                        FOV.Line.Visible = true

                        FOV.LineOutline.From = FOV.Line.From
                        FOV.LineOutline.To = FOV.Line.To
                        FOV.LineOutline.Visible = true
                    else
                        FOV.Line.Visible = false
                        FOV.LineOutline.Visible = false
                    end

                    -- Visualize target - only for sticky target
                    if Spoof.Silent.Redirection.Info.Enabled and Spoof.Silent.Redirection.Visualizetarget.Enabled and StickyTarget and StickyTarget.Character then
                        local Root = StickyTarget.Character[Spoof.Silent["Redirection"]["HitPart"].Target]
                        local RootToViewportPoint, IsVisible = Camera.WorldToViewportPoint(Camera, Root.Position)
                        FOV.MouseLink.Color = Spoof.Silent["Redirection"]
                        FOV.MouseLink.Transparency = 1
                        FOV.MouseLink.Thickness = 0.4
                        FOV.MouseLink.Filled = false
                        FOV.MouseLink.Radius = 20
                        FOV.MouseLink.Visible = true
                        FOV.MouseLink.Position = Vector2.new(RootToViewportPoint.X, RootToViewportPoint.Y)
                    else
                        FOV.MouseLink.Position = Vector2.new()
                        FOV.MouseLink.Visible = false
                    end
                end
            )

            local function GetClosestPlayer()
                local MaxDist = math.huge
                local Target = nil
                
                for _, v in pairs(Players:GetPlayers()) do
                    if v ~= LocalPlayer and v.Character and v.Character:FindFirstChild("Humanoid") and 
                    v.Character.Humanoid.Health > 0 and v.Character:FindFirstChild(Spoof.Camlock.HitPart) then
                        local ScreenPos, OnScreen = Camera:WorldToScreenPoint(v.Character[Spoof.Camlock.HitPart].Position)
                        local Distance = (Vector2.new(Mouse.X, Mouse.Y) - Vector2.new(ScreenPos.X, ScreenPos.Y)).Magnitude
                        
                        if Distance < MaxDist and OnScreen then
                            MaxDist = Distance
                            Target = v
                        end
                    end
                end
                
                return Target
            end

            local Target
            local Enabled = false
            local Holding = false

            -- Handle both toggle and hold modes for camlock
            UIS.InputBegan:Connect(function(Input)
                if Input.KeyCode == Enum.KeyCode[Spoof.Camlock.Key] then
                    if Spoof.Camlock.Toggle then
                        Enabled = not Enabled
                        if Enabled then
                            Target = GetClosestPlayer()
                        else
                            Target = nil
                        end
                    else
                        Holding = true
                        Target = GetClosestPlayer()
                    end
                end
                
                if Input.KeyCode == Enum.KeyCode[Spoof.Silent.Redirection.Visualizetarget.Tracer.Key] then
                    Spoof.Silent.Redirection.Visualizetarget.Tracer.Enabled = not Spoof.Silent.Redirection.Visualizetarget.Tracer.Enabled
                end
            end)

            UIS.InputEnded:Connect(function(Input)
                if Input.KeyCode == Enum.KeyCode[Spoof.Camlock.Key] and not Spoof.Camlock.Toggle then
                    Holding = false
                    Target = nil
                end
            end)

            RunService.RenderStepped:Connect(function()
                if (Enabled or Holding) and Target and Target.Character and Target.Character:FindFirstChild(Spoof.Camlock.HitPart) then
                    local TargetPos = Target.Character[Spoof.Camlock.HitPart].Position
                    
                    if Spoof.Camlock.Prediction.Enabled then
                        local Velocity = Target.Character[Spoof.Camlock.HitPart].Velocity
                        local Distance = (Target.Character[Spoof.Camlock.HitPart].Position - Camera.CFrame.Position).Magnitude
                        local TimeToTarget = Distance / 1000
                        TargetPos = TargetPos + (Velocity * Spoof.Camlock.Prediction.Amount)
                    end
                    
                    if Spoof.Camlock.Shake.Enabled then
                        TargetPos = TargetPos + Vector3.new(
                            math.random(-Spoof.Camlock.Shake.X, Spoof.Camlock.Shake.X) / 100,
                            math.random(-Spoof.Camlock.Shake.Y, Spoof.Camlock.Shake.Y) / 100,
                            math.random(-Spoof.Camlock.Shake.Z, Spoof.Camlock.Shake.Z) / 100
                        )
                    end

                    local CameraPosition = Camera.CFrame.Position
                    local TargetPosition = TargetPos
                    
                    -- Calculate target CFrame with improved aiming
                    local TargetCFrame = CFrame.lookAt(CameraPosition, TargetPosition)
                    
                    -- Smoothly interpolate to target angles with improved logic
                    if Spoof.Camlock.Smoothness.Enabled then
                        local LerpAmount = Spoof.Camlock.Smoothness.Amount
                        
                        if Spoof.Camlock.AimAssist.Enabled then
                            local ScreenPos, OnScreen = Camera:WorldToScreenPoint(TargetPosition)
                            if OnScreen then
                                local ScreenCenter = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2)
                                local Distance = (Vector2.new(ScreenPos.X, ScreenPos.Y) - ScreenCenter).Magnitude
                                
                                if Distance < 150 then
                                    LerpAmount = LerpAmount * (1 + Spoof.Camlock.AimAssist.Strength)
                                end
                            end
                        end
                        
                        -- Improved smooth camera movement
                        local CurrentCFrame = Camera.CFrame
                        local NewCFrame = CurrentCFrame:Lerp(TargetCFrame, LerpAmount)
                        
                        -- Apply rotation only, preserve original camera position
                        Camera.CFrame = CFrame.new(CurrentCFrame.Position) * NewCFrame.Rotation
                    else
                        -- Direct camera rotation without changing position
                        Camera.CFrame = CFrame.new(Camera.CFrame.Position) * TargetCFrame.Rotation
                    end
                end
            end)

            -- Add Triggerbot Variables
            local TriggerEnabled = false
            local LastShot = 0
            local TriggerHolding = false

            -- Add Triggerbot Toggle/Hold Handler
            UIS.InputBegan:Connect(function(Input)
                if Input.KeyCode == Enum.KeyCode[Spoof.Triggerbot.Key] and Spoof.Triggerbot.Enabled then
                    if Spoof.Triggerbot.Hold then
                        TriggerHolding = true
                        TriggerEnabled = true
                    else
                        TriggerEnabled = not TriggerEnabled
                    end
                end
            end)

            UIS.InputEnded:Connect(function(Input)
                if Input.KeyCode == Enum.KeyCode[Spoof.Triggerbot.Key] and Spoof.Triggerbot.Hold then
                    TriggerHolding = false
                    TriggerEnabled = false
                end
            end)

            -- Add Triggerbot Logic
            RunService.RenderStepped:Connect(function()
                if TriggerEnabled and Spoof.Triggerbot.Enabled and (not Spoof.Triggerbot.Hold or TriggerHolding) then
                    local MouseLocation = UIS:GetMouseLocation()
                    local NearestPlayer = nil
                    local ShortestDistance = Spoof.Triggerbot.Distance

                    for _, Player in pairs(Players:GetPlayers()) do
                        if Player ~= LocalPlayer and Player.Character and Player.Character:FindFirstChild("HumanoidRootPart") then
                            -- Team Check
                            if Spoof.Triggerbot.CheckTeam and Player.Team == LocalPlayer.Team then
                                continue
                            end

                            -- Knocked Check for Da Hood
                            if Spoof.Triggerbot.CheckKnocked and game.PlaceId == 2788229376 then
                                if Player.Character:FindFirstChild("GRABBING_CONSTRAINT") or 
                                Player.Character:FindFirstChild("BodyEffects")["K.O"].Value then
                                    continue
                                end
                            end

                            local Vector, IsVisible = Camera:WorldToViewportPoint(Player.Character.HumanoidRootPart.Position)
                            if IsVisible then
                                -- Visibility Check
                                if Spoof.Triggerbot.VisibilityCheck then
                                    local Ray = Ray.new(Camera.CFrame.Position, (Player.Character.Head.Position - Camera.CFrame.Position).Unit * 500)
                                    local Hit, Position = workspace:FindPartOnRayWithIgnoreList(Ray, {LocalPlayer.Character, Camera})
                                    
                                    if not Hit or not Hit:IsDescendantOf(Player.Character) then
                                        continue
                                    end
                                end

                                local Distance = (Vector2.new(Vector.X, Vector.Y) - MouseLocation).Magnitude
                                if Distance < ShortestDistance then
                                    ShortestDistance = Distance
                                    NearestPlayer = Player
                                end
                            end
                        end
                    end

                    if NearestPlayer and tick() - LastShot > Spoof.Triggerbot.Delay then
                        mouse1click()
                        LastShot = tick()
                    end
                end
            end)
        end
    )()

    getgenv().Loaded = true




getgenv().Spoof = {
    ["Options"] = {
        ["Version"] = ("0.0.4.7"), -- // Do Not Touch. This Will Detect If You Are Using Old Table
        ["Gui"] = (false), -- // Shows You An Gui That You Can Change Stuff Directly
        ["GuiV2"] = (false), -- // Shows You An Gui V2 That You Can Change Stuff Directly
        ["Intro"] = (false), -- // Shows You An Intro
        ["Internal"] = (false), -- // Shows An Console That You Can Change ChatCommands On
        ["AutoGetUp"] = (true), -- // If You Are Laying Down Unable To Stand Up It Will AutoMatically Get You Up
        ["AntiError"] = (true), -- // Removes Errors In Console
        ["BypassData"] = (false), -- // Bypasses Many Methods Of Most Cheat Detections
        ["AutoLowGfx"] = (false), -- // AutoMatically Disables Textures In The Map
        ["MuteBoomBox"] = (true), -- // AutoMatically Disables BoomBoxes Music
        ["RemoveSeats"] = (false), -- // AutoMatically Removes Seats
        ["GetInformation"] = (true), -- // Sends Current Execution And How Long It Took You To Load
        ["NotificationMode"] = {
            ["Enabled"] = (true),
            ["Silent"] = (true),
            ["AimAssist"] = (false),
            ["PanicMode"] = (true),
            ["Suspicious"] = (true),
            ["CheatDetected"] = (true),
            ["FakeSpike"] = (true),
            ["Desync"] = (true), 
            ["Esp"] = (true),
            ["Misc"] = (true)
        } -- // Sends Notification When you Enabled / Disabled Stuff
    },
    ["PanicMode"] = {
        ["Enabled"] = (true), -- // Enables The Key For PanicMode
        ["KeyBind"] = ("P") -- // The Key That Enables / Disables The PanicMode
    },
    ["F9Cleaner"] = {
        ["Enabled"] = (false), -- // Enables The Key For F9Cleaner
        ["KeyBind"] = ("N") -- // The Key That Enables / Disables The F9Cleaner
    },
    ["FakeSpike"] = {
        ["Enabled"] = (false), -- // Enables The Key For FakeSpike
        ["KeyBind"] = ("J"), -- // The Key That Enables / Disables The FakeSpike
        ["Power"] = (500), -- // How Much Ping It Goes Up To
        ["ToggleMode"] = (false), -- // You Toggle The Spike Instead
        ["Delay"] = (4), -- // How Much Delay Its Untill The Normal Ping Turns Back
    },
    ["ModDetection"] = {
        ["Enabled"] = (true), -- // Enables / Disable Mod Detection
        ["Delay"] = (3), -- // Makes It More Legit For Kick Method
        ["Rank"] = (200), -- // Detects If The Users Group Rank Is Higher Then The Number
        ["Method"] = ("Kick"), -- // What Detection It Sends (Kick, Notification)
    },
    ["Silent"] = {
        ["Enabled"] = (true), -- // Enable / Disable Silent Aim
        ["UseSilentKeyBind"] = (false), -- // Use The KeyBind To Enable / Disable The Silent Aim
        ["KeyBind"] = ("B"), -- // The Key That Enables / Disables The Silent Aim
        ["LegitMode"] = (false), -- // You Wont Make You Curve That Much. You Need To Predict Atleast For It To Work
        ["BlatantMode"] = (true), -- // This Will Make You Hit More But It Will Effect The Resolver Detection. It Will Still Resolve But The More Advanced Will Probably Not.
        
        ["ForceLock"] = (true), -- // You Press The Button To Target The Player. RISKY!
        ["ForceLock_AimAssistTarget"] = (true), -- // Uses AimAssist Target Instead Of Silent Aim
        ["ForceKeyBind"] = ("H"), -- // The Key That Gets The Target
        
        ["PredictMovement"] = (true), -- // Predicts Target Position And MoveMent
        ["Prediction"] = (0.122911), -- // How Much Power It Predicts The Target
        ["Part"] = ("HumanoidRootPart"), -- // What Part It Targerts
        ["UseAirPart"] = (false), -- // When Target Is In The Air Its Gonna Force To Shoot On Air Part
        ["AirPart"] = ("LowerTorso"), -- // The Parts It Targets On When Player Is In The Air
        ["ClosestPart"] = (true), -- // Automatically Gets The Closest Part Of The Target And Uses That Position
        ["ClosestPoint"] = (false), -- // Automatically Gets The Closest Point Of The Target Part And Uses That Position
        ["UseWhitelistedParts"] = (true), -- // Makes So You Only Get Custom Parts
        ["WhitelistedPart"] = {"Head", "UpperTorso", "LowerTorso", "RightFoot", "LeftFoot",}, -- // Whitelists Certain Part For ClosestPart Function. Example {"HumanoidRootPart", "Head"}
        ["AntiAimViewer"] = (true), -- // Bypasses The Mouse Position For The Server
        ["HitChance"] = (79), -- // The Chance You Will Hit The Target
        ["AirHitChance"] = (79), -- // The Chance You Will Hit The Target In The Air
        
        ["Humanize"] = (false), -- // Makes So The Silent Doesnt Hit The Same Position (Randomizes The Position)
        ["HumanizeValue"] = (5), -- // Makes So How Much Power It Changes
        
        ["TriggerBot"] = (false), -- // Shoots AutoMatically When You Have An Target Locked
        ["TriggerBot_HoldMode"] = (false), -- // Enables While Only Holding The Key
        ["TriggerBot_Delay"] = (100), -- // Delays The Click (Milliseconds)
        ["TriggerBotMouseKey"] = ("MouseButton3"), -- // Mouse Key To Enable / Disable TriggerBot.
        ["TriggerBot_HotKey"] = (false), -- // Will Use KeyBoard Keys Instead Of Mouse Keys
        ["TriggerBotKey"] = ("Q"), -- // What KeyBoard Key
        
        ["AntiGroundShots"] = (true), -- // Makes So You Dont Shoot The Ground/Floor
        ["AntiGroundValue"] = (0.15), -- // How Much Power It Uses For The Silent
        ["AntiGroundActivation"] = (-10), -- // The Value Its Gonna Start Activating
        
        ["Custom_AntiAimViewerPoint"] = {
            ["Enabled"] = (true), -- // Enable / Disable Custom Anti AimViewer
            ["RemoteEvent"] = (function(Pos) -- // This Is Only For Games That Arent Supported With The Current Anti Aim Viewer
                local MainEvent = game:GetService("ReplicatedStorage").MainEvent -- // The MainEvent Path
                local Args = {
                    [1] = "UpdateMousePos", -- // The String
                    [2] = Pos -- // The Mouse Position
                }
                return Args, MainEvent -- // Returns Args And MainEvent 
                -- // Use This Script To Get The MainEvent And The Args
                -- // loadstring(game:HttpGet("https://github.com/exxtremestuffs/SimpleSpySource/raw/master/SimpleSpy.lua"))()
            end)
        },
         ["PingPrediction"] = {
            ["Enabled"] = (true), -- // Automatically Sets The Prediction On What Ping You Are On
            ["AutoMatic"] = (false), -- // Automatically Generates An Prediction For Your Ping
            ["RefreshRate"] = (0.02), -- // Waits This Seconds To Execute Again
            ["P200_Inf"] = (0.2354),
            ["P190_200"] = (0.2129),
            ["P180_190"] = (0.1902),
            ["P170_180"] = (0.1818),
            ["P160_170"] = (0.1788),
            ["P150_160"] = (0.1720),
            ["P140_150"] = (0.1684),
            ["P130_140"] = (0.1612),
            ["P120_130"] = (0.1532),
            ["P110_120"] = (0.1512),
            ["P100_110"] = (0.141987),
            ["P90_100"] = (0.142007),
            ["P80_90"] = (0.138),
            ["P70_80"] = (0.1320),
            ["P60_70"] = (0.1357),
            ["P50_60"] = (0.11526),
            ["P40_50"] = (0.10023),
            ["P30_40"] = (0.0852),
            ["P20_30"] = (0.128),
            ["P10_20"] = (0.10087127181718181)
        },
        ["Fov"] = {
            ["Visible"] = (false), -- // If The Circle Is Showing Or Not
            ["Method"] = ("Mouse"), -- // What Type Of Position The Fov Is Gonna Be (Mouse, Screen)
            ["Filled"] = (false), -- // If The Circle Is Filled
            ["Transparency"] = (1), -- // The Circle Transparency
            ["Color"] = (Color3.fromRGB(200, 200, 200)), -- // Circle Color
            ["Offset"] = (Vector2.new(0, 0)), -- // Circle Position + The Offset
            ["StickyFov"] = (false), -- // Puts The Circle On Target Position
            ["Radius"] = (20.8) -- // How Big The Circle Is
        },
        ["GunSettings"] = {
            ["Enabled"] = (false), -- // Enable / Disable GunSettings
            ["Methods"] = {
                ["Fov"] = (false), 
                ["Range"] = (false), 
                ["Prediction"] = (false), 
                ["HitChance"] = (false), 
                ["AirHitChance"] = (false), 
                ["Smoothness"] = (false), 
                ["AirSmoothness"] = (false)
            }, -- // What Things Its Gonna Change Like If Fov Is On It Will Change Fov. Using RangeMode Will OverWrite Instant Fov Changes.
            ["Dynamic"] = {
                ["Enabled"] = (false), -- // Will Smoothly Changes The Method
                ["Time"] = (0.5), -- // How Much Time Its Gonna Take To Complete The Motion
                ["EasingStyle"] = ("Exponential"), -- // What Smoothning Method For Method Control Motion 
                ["EasingDirection"] = ("In") -- // What Smoothning Method For Method Control Direction
            },
            ["Far_Activation"] = (1/0), -- // Just Keep It At Math.Huge Or 1/0 (Inf Studs)
            ["Medium_Activation"] = (57), -- // How Far By Using Studs
            ["Close_Activation"] = (32), -- // How Far By Using Studs
            
            ["Revolver"] = {
            ["Fov"] = (9.8),        ["Prediction"] = (0.122312),         ["HitChance"] = (100),      ["AirHitChance"] = (100),       ["Smoothness"] = (0.023),         ["AirSmoothness"] = (0.023),
            ["CloseFov"] = (9.8),   ["ClosePrediction"] = (0.122312),    ["CloseHitChance"] = (100), ["CloseAirHitChance"] = (100),  ["CloseSmoothness"] = (0.023),    ["CloseAirSmoothness"] = (0.023),
            ["MedFov"] = (7.2),      ["MedPrediction"] = (0.122312),      ["MedHitChance"] = (100),   ["MedAirHitChance"] = (100),    ["MedSmoothness"] = (0.023),      ["MedAirSmoothness"] = (0.023),
            ["FarFov"] = (3.6),        ["FarPrediction"] = (0.122312),      ["FarHitChance"] = (100),   ["FarAirHitChance"] = (100),    ["FarSmoothness"] = (0.023),      ["FarAirSmoothness"] = (0.023),
            },
            ["Double-Barrel SG"] = {
            ["Fov"] = (9.8),          ["Prediction"] = (0.122312),         ["HitChance"] = (100),      ["AirHitChance"] = (100),       ["Smoothness"] = (0.023),          ["AirSmoothness"] = (0.023),
            ["CloseFov"] = (9.8),     ["ClosePrediction"] = (0.122312),    ["CloseHitChance"] = (100), ["CloseAirHitChance"] = (100),  ["CloseSmoothness"] = (0.023),     ["CloseAirSmoothness"] = (0.023),
            ["MedFov"] = (7.2),       ["MedPrediction"] = (0.122312),      ["MedHitChance"] = (100),   ["MedAirHitChance"] = (100),    ["MedSmoothness"] = (0.023),       ["MedAirSmoothness"] = (0.023),
            ["FarFov"] = (3.6),        ["FarPrediction"] = (0.122312),      ["FarHitChance"] = (100),   ["FarAirHitChance"] = (100),    ["FarSmoothness"] = (0.023),       ["FarAirSmoothness"] = (0.023),
            },
            ["Shotgun"] = {
            ["Fov"] = (9.8),          ["Prediction"] = (0.122312),         ["HitChance"] = (100),      ["AirHitChance"] = (100),       ["Smoothness"] = (0.023),          ["AirSmoothness"] = (0.023),
            ["CloseFov"] = (9.8),     ["ClosePrediction"] = (0.122312),    ["CloseHitChance"] = (100), ["CloseAirHitChance"] = (100),  ["CloseSmoothness"] = (0.023),     ["CloseAirSmoothness"] = (0.023),
            ["MedFov"] = (7.2),       ["MedPrediction"] = (0.122312),      ["MedHitChance"] = (100),   ["MedAirHitChance"] = (100),    ["MedSmoothness"] = (0.023),       ["MedAirSmoothness"] = (0.023),
            ["FarFov"] = (3.6),        ["FarPrediction"] = (0.122312),      ["FarHitChance"] = (100),   ["FarAirHitChance"] = (100),    ["FarSmoothness"] = (0.023),       ["FarAirSmoothness"] = (0.023),
            },
            ["TacticalShotgun"] = {
            ["Fov"] = (9.8),          ["Prediction"] = (0.122312),         ["HitChance"] = (100),      ["AirHitChance"] = (100),       ["Smoothness"] = (0.023),          ["AirSmoothness"] = (0.023),
            ["CloseFov"] = (9.8),     ["ClosePrediction"] = (0.122312),    ["CloseHitChance"] = (100), ["CloseAirHitChance"] = (100),  ["CloseSmoothness"] = (0.023),     ["CloseAirSmoothness"] = (0.023),
            ["MedFov"] = (7.2),       ["MedPrediction"] = (0.122312),      ["MedHitChance"] = (100),   ["MedAirHitChance"] = (100),    ["MedSmoothness"] = (0.023),       ["MedAirSmoothness"] = (0.023),
            ["FarFov"] = (3.6),        ["FarPrediction"] = (0.122312),      ["FarHitChance"] = (100),   ["FarAirHitChance"] = (100),    ["FarSmoothness"] = (0.023),       ["FarAirSmoothness"] = (0.023),
            },
            ["SMG"] = {
            ["Fov"] = (9.8),         ["Prediction"] = (0.122312),          ["HitChance"] = (100),      ["AirHitChance"] = (100),       ["Smoothness"] = (0.023),         ["AirSmoothness"] = (0.023),
            ["CloseFov"] = (9.8),    ["ClosePrediction"] = (0.122312),     ["CloseHitChance"] = (100), ["CloseAirHitChance"] = (100),  ["CloseSmoothness"] = (0.023),    ["CloseAirSmoothness"] = (0.023),
            ["MedFov"] = (7.2),      ["MedPrediction"] = (0.122312),        ["MedHitChance"] = (100),   ["MedAirHitChance"] = (100),    ["MedSmoothness"] = (0.023),      ["MedAirSmoothness"] = (0.023),
            ["FarFov"] = (3.6),      ["FarPrediction"] = (0.122312),       ["FarHitChance"] = (100),   ["FarAirHitChance"] = (100),    ["FarSmoothness"] = (0.023),      ["FarAirSmoothness"] = (0.023),
            },
            ["Silencer"] = {
            ["Fov"] = (9.8),        ["Prediction"] = (0.122312),         ["HitChance"] = (100),      ["AirHitChance"] = (100),       ["Smoothness"] = (0.023),         ["AirSmoothness"] = (0.023),
            ["CloseFov"] = (9.8),   ["ClosePrediction"] = (0.122312),    ["CloseHitChance"] = (100), ["CloseAirHitChance"] = (100),  ["CloseSmoothness"] = (0.023),    ["CloseAirSmoothness"] = (0.023),
            ["MedFov"] = (7.2),      ["MedPrediction"] = (0.122312),      ["MedHitChance"] = (100),   ["MedAirHitChance"] = (100),    ["MedSmoothness"] = (0.023),      ["MedAirSmoothness"] = (0.023),
            ["FarFov"] = (3.6),        ["FarPrediction"] = (0.122312),      ["FarHitChance"] = (100),   ["FarAirHitChance"] = (100),    ["FarSmoothness"] = (0.023),      ["FarAirSmoothness"] = (0.023),
            },
            ["Rifle"] = {
            ["Fov"] = (9.8),          ["Prediction"] = (0.122312),          ["HitChance"] = (100),      ["AirHitChance"] = (100),       ["Smoothness"] = (0.023),        ["AirSmoothness"] = (0.023),
            ["CloseFov"] = (9.8),     ["ClosePrediction"] = (0.122312),    ["CloseHitChance"] = (100), ["CloseAirHitChance"] = (100),  ["CloseSmoothness"] = (0.023),     ["CloseAirSmoothness"] = (0.023),
            ["MedFov"] = (7.2),      ["MedPrediction"] = (0.122312),   ["MedHitChance"] = (100),   ["MedAirHitChance"] = (100),    ["MedSmoothness"] = (0.023),       ["MedAirSmoothness"] = (0.023),
            ["FarFov"] = (3.6),      ["FarPrediction"] = (0.122312),      ["FarHitChance"] = (100),   ["FarAirHitChance"] = (100),    ["FarSmoothness"] = (0.023),       ["FarAirSmoothness"] = (0.023),
            },
            ["AR"] = {
            ["Fov"] = (9.8),         ["Prediction"] = (0.122312),          ["HitChance"] = (100),      ["AirHitChance"] = (100),       ["Smoothness"] = (0.023),          ["AirSmoothness"] = (0.023),
            ["CloseFov"] = (9.8),    ["ClosePrediction"] = (0.122312),     ["CloseHitChance"] = (100), ["CloseAirHitChance"] = (100),  ["CloseSmoothness"] = (0.023),     ["CloseAirSmoothness"] = (0.023),
            ["MedFov"] = (7.2),      ["MedPrediction"] = (0.122312),        ["MedHitChance"] = (100),   ["MedAirHitChance"] = (100),    ["MedSmoothness"] = (0.023),       ["MedAirSmoothness"] = (0.023),
            ["FarFov"] = (3.6),      ["FarPrediction"] = (0.122312),       ["FarHitChance"] = (100),   ["FarAirHitChance"] = (100),    ["FarSmoothness"] = (0.023),       ["FarAirSmoothness"] = (0.023),
            },
            ["AK47"] = {
            ["Fov"] = (9.8),         ["Prediction"] = (0.122312),          ["HitChance"] = (100),      ["AirHitChance"] = (100),       ["Smoothness"] = (0.023),          ["AirSmoothness"] = (0.023),
            ["CloseFov"] = (9.8),    ["ClosePrediction"] = (0.122312),     ["CloseHitChance"] = (100), ["CloseAirHitChance"] = (100),  ["CloseSmoothness"] = (0.023),     ["CloseAirSmoothness"] = (0.023),
            ["MedFov"] = (7.2),      ["MedPrediction"] = (0.122312),        ["MedHitChance"] = (100),   ["MedAirHitChance"] = (100),    ["MedSmoothness"] = (0.023),       ["MedAirSmoothness"] = (0.023),
            ["FarFov"] = (3.6),      ["FarPrediction"] = (0.122312),       ["FarHitChance"] = (100),   ["FarAirHitChance"] = (100),    ["FarSmoothness"] = (0.023),       ["FarAirSmoothness"] = (0.023),
            }
        }
    },
    ["AimAssist"] = {
        ["Enabled"] = (true), -- // Enable / Disable AimAssist
        ["KeyBind"] = ("C"), -- // The Key To Lock Onto A Player
        ["HoldMode"] = (false), -- // Enables While Only Holding The Key
        ["Method"] = ("Camera"), -- // Wich Thing It Uses For AimAssist (Mouse, Camera)

        ["PredictMovement"] = (true), -- // Predicts Target Position And MoveMent
        ["Prediction"] = (0.1), -- // How Much Power It Predicts The Target
        ["Part"] = ("UpperTorso"), -- // The Part That Aim Assist Locks On
        ["ClosestPart"] = (false), -- // Automatically Gets The Closest Part Of The Target And Uses That Position
        ["RandomPart"] = (false), -- // Randomizes An Part Of The Target And Uses That Position. Will OverWrite ClosestPart
        ["EnableChance"] = (false), -- // Makes So Theres A Chance The AimAssist Will Enabled
        ["Chance"] = (30), -- // The Chance The AimAssist Will Be Enabled
        ["UseCircleRadius"] = (true), -- // Only Locks On To People Inside The Circle
        ["DisableOutSideCircle"] = (false), -- // If Target Is OutSide The Circle It Disables The Aim Assist
        
        ["FirstPerson"] = (true), -- // Only Enables When Your On FirstPerson
        ["ThirdPerson"] = (true), -- // Only Enables When Your On ThirdPerson
        
        ["UseSmoothness"] = (false), -- // Enable / Disable Smoothness
        ["Smoothness_X"] = (0.058), -- // How Smooth The Aim Assist Is On X
        ["Smoothness_Y"] = (0.044), -- // How Smooth The Aim Assist Is On Y 

        ["AirSmoothness"] = (false), -- // Uses AirSmoothness When The Target Is In The Air
        ["AirSmoothness_X"] = (0.01), -- // How Smooth The Aim Assist Is On X In Target Air
        ["AirSmoothness_Y"] = (0.0088), -- // How Smooth The Aim Assist Is On Y In Target Air
        
        ["Advanced"] = {
            ["WallCheck_V2"] = (false), -- // Loop Checks If Theres A Wall Infront Of The Target
            ["TickBased"] = (false), -- // Executes On Based Tick Changes
            ["Stutter"] = (0), -- // Checks Last Tick If Its High Or Not. If Its High It Disables For Security Reasons
            ["EasingStyle"] = ("Exponential"), -- // What Smoothning Method For AimAssist To Control Motion 
            ["EasingDirection"] = ("In") -- // What Smoothning Method For AimAssist To Control Direction
        },
        ["FrameSkip"] = {
            ["Enabled"] = (false), -- // Flicks To Targets Part
            ["Power"] = (0.95), -- // How Much Power It Flicks To The Target
            ["UsePrediction"] = (false), -- // Adds Prediction For Flicking
            ["TargetPart"] = {["Enabled"] = (false), ["Part"] = ("Head")}, -- // Flicks To The Part
            ["KeyBind"] = ("Q") -- // The Keybind To Activate The Flick
        },
        ["Shake"] = {
            ["Enabled"] = (false), -- // Enable / Disable Shake
            ["Shake_X"] = (20), -- // How Much It Shakes On X
            ["Shake_Y"] = (15), -- // How Much It Shakes On Y
            ["Shake_Z"] = (20), -- // How Much It Shakes On Z
            ["AirShake"] = (true), -- // Uses Shake Percentage When The Target Is In The Air
            ["AirPercentage"] = (50) -- // How Much Percent It Removed On Shake When Target Is In The Air. Yes This Can Go Over 100+
        },
        ["Fov"] = {
            ["Visible"] = (false), -- // If The Circle Is Showing Or Not
            ["Filled"] = (false), -- // If The Circle Is Filled
            ["Transparency"] = (0.5), -- // Circles Transparency
            ["Color"] = (Color3.fromRGB(0, 0, 0)), -- // Circle Color
            ["Radius"] = (70) -- // How Big The Circle Is
        }
    },
    ["UniversalCheck"] = {
        ["InVisibleCheck"] = (true), -- // Checks If Target Is InVisible
        ["ForceFieldCheck"] = (false), -- // Checks If Target Has ForceFeild. That Blue Bubble Thing When You Spawn
        ["TargetDeathCheck"] = (true), -- // Disables When Target Is Dead
        ["PlayerDeathCheck"] = (true), -- // Disables When You Die
        ["ToolOut"] = (false), -- // AimAssist Only Enables When An Tool Is Out
        
        ["WallCheck"] = (true), -- // Checks If There Is Nothing Infront Of The Target
        ["WallCheck_V2"] = (false), -- // Checks If The Velocity Is Predicting Into An Wall
        ["FriendCheck"] = (false), -- // Checks If Target Is Your Friend
        ["TeamCheck"] = (false), -- // Checks If Player Is In the Same Team
        
        ["CrewCheck"] = (false), -- // Checks If Target Is In Your Crew
        ["KoCheck"] = (true), -- // Checks If Target Is Grabbed Or Knocked
        ["ReloadCheck"] = (false), -- // Checks If You Are Realoding
        ["NoAmmoCheck"] = (false), -- // Checks If Youre Gun Has 0 Ammo
        
        ["Advanced"] = {
            ["Target_Bots"] = (false), -- // Makes The Silent And AimAssist Target The Bot. RISKY!
            ["Bot_Path"] = ("NPC") -- // Gets The Folder Path Where The Bots Are And Uses It. In The Current Workspace Folder
        }
    },
    ["ChatCommands"] = {
        ["Enabled"] = (true), -- // Enable / Disable Chat Commands

        -- // Silent ChatCommands
        ["Silent_Enabled"] = ("!senabled"), -- // The Command To Enable / Disable Silent (With false/true)
        ["Silent_Prediction"] = ("!spred"), -- // The Command To Change Silent Prediction (With Numbers)
        ["Silent_Fov_Size"] = ("!sfov"), -- // The Command To Change Silent Fov (With Numbers)
        ["Silent_Fov_Show"] = ("!sshow"), -- // The Command To Change Silent (With false/true)
        ["Silent_HitChance"] = ("!schance"), -- // The Command To Change Silent HitChance (With Numbers)
        ["Silent_LegitMode"] = ("!slegit"), -- // The Command To Change Silent LegitMode (With false/true)
        ["Silent_BlatantMode"] = ("!sblatant"), -- // The Command To Change Silent BlatantMode (With false/true)

        -- // AimAssist ChatCommands
        ["AimAssist_Enabled"] = ("!aenabled"), -- // The Command To Enable / Disable AimAssist (With false/true)
        ["AimAssist_Prediction"] = ("!apred"), -- // The Command To Change AimAssist Prediction (With Numbers)
        ["AimAssist_Fov_Size"] = ("!afov"), -- // The Command To Change AimAssist Fov (With Numbers)
        ["AimAssist_Fov_Show"] = ("!ashow"), -- // The Command To Change AimAssist (With false/true)
        ["AimAssist_SmoothX"] = ("!smoothx"), -- // The Command To Change AimAssist SmoothNess X Value (With Numbers)
        ["AimAssist_SmoothY"] = ("!smoothy"), -- // The Command To Change AimAssist SmoothNess Y Value (With Numbers)
        ["AimAssist_Shake"] = ("!ashake"), -- // The Command To Change AimAssist Shake Value (With Numbers)
        
        -- // Misc ChatCommands
        ["RejoinServer"] = ("rejserv"), -- // The Command To Rejoin The Server You Are In
        ["RandomServer"] = ("rejoin."), -- // The Command To Rejoin An Random Server
        
        ["SaveConfig"] = ("savecon"), -- // Creates An Txt That Saves The Table. (Example Savecon ConfigName)
        ["LoadConfig"] = ("loadcon"), -- // Loads An New Table. (Example loadcon ConfigName)

        ["CrashMode"] = (". "), -- // The Command To Crash Roblox
        ["CrashMethod"] = ("Freeze") -- // Method To Crash Roblox (Freeze, Shutdown)
    },
    ["InventorySorter"] = {
        ["Enabled"] = (false), -- // Sorts The Inventory Tab
        ["KeyBind"] = ("M"), -- // What KeyBind You Enabled
        ["UseFood"] = (false), -- // Sorts Also Food
        ["Slots"] = {
            ("[Double-Barrel SG]"), -- // The First Slot Item
            ("[Revolver]"), -- // The Second Slot Item
            ("[TacticalShotgun]"), -- // The Third Slot Item
            ("[Shotgun]"), -- // The Fourth Slot Item
            ("[Katana]") -- // The Fifth Slot Item
            -- // More Can Be Added (Max Is 10)
        }, -- // Wich Slots The Guns Are Gonna Be At (Starts Up And Goes Down)
    },
    ["MemorySpoofer"] = {
        ["Enabled"] = (false), -- // Edits Memory Numbers On Roblox Gui
        ["Delay"] = (1), -- // The RefreshRate On Random Numbers
        ["Maximum"] = (972.81), -- // The Maximum It Can Generate
        ["Lowest"] = (952.83) -- // The Lowest It Can Generate
    },
    ["Macro"] = {
        -- // For Speed Macro
        ["Speed_Enabled"] = (true), -- // Enable / Disable Macro 
        ["Speed_Delay"] = (1), -- // The Delay For The Macro (The Higher The Slower)
        ["Speed_KeyBind"] = ("X"), -- // Key To Macro
        ["Speed_HoldMode"] = (true), -- // Enables While Only Holding The KeyBind
        ["Speed_MacroAbuse"] = (true), -- // This Will Bypass Anti Gun Macro
        ["Speed_ThirdPersonV2"] = (false), -- // This Makes The Macro Much Faster. But Its Only Good For People That Has Under 60-
        ["Speed_Method"] = ("FirstPerson"), -- // 3 Kinds Of Method (ThirdPerson, FirstPerson, Shift)
        
        -- // For Emote Macro 
        ["Lay_Emote"] = (false), -- // Enable / Disable Lay_Emote Key
        ["Lay_KeyBind"] = ("G"), -- // Key To Execute Lay
        ["Greet_Emote"] = (false), -- // Enable / Disable Greet_Emote Key
        ["Greet_Keybind"] = ("Y"), -- // Key To Execute Greet
        
        -- // For Noclip Macro
        ["Noclip_Macro"] = (false), -- // Enable / Disable Noclip Key
        ["Noclip_HoldMode"] = (false), -- // Enables While Only Holding The Key
        ["Noclip_KeyBind"] = ("Q"), -- // Key To Enable Macro
        
        -- // For Rotation Mode
        ["RotationMode"] = (false), -- // Enable / Disable Rotation Key
        ["Degrees"] = (360), -- // How Much You Turn
        ["RotationSpeed"] = (5), -- // How Fast You Turn
        ["Rotation_KeyBind"] = ("V") -- // Key To Enable Macro
    },
    ["Desync"] = {
        ["Enabled"] = (false), -- // Enable / Disable Desync
        ["HealthDeActivation"] = (7), -- // Disables The Desync When Your Health Is That Low
        ["UseDesyncKey"] = (false), -- // Use The KeyBind To Enable / Disable The Desync Desync Key
        ["DesyncKey"] = ("X"), -- // Key To Enable / Disable Desync
        ["HoldMode"] = (false), -- // Enables While Only Holding The Key
        
        ["Visualize"] = {["Enabled"] = (false), ["Radius"] = (30), ["Color"] = (Color3.fromRGB(255, 255, 255))}, -- // Shows An Dot Where The Velocity Is
        ["Method"] = ("Vel_StandBy"), -- // Diffrent Methods To Change Velocity (Vel_Multi, Custom_Vel, Vel_StandBy, Vel_Under, Vel_Zero) 2 Diffrent Methods To Change Server Position (Freeze_Pos, Slow_Data)
        ["Power"] = (5), -- // How Much Velocity The Method Is Using. Vel_StandBy, Custom_Vel, Vel_Zero And Server Position Changer Does Not Need This
        
        ["Custom"] = {
            ["Vel_X"] = (50), -- // How Much Power Is On X
            ["Vel_Y"] = (50), -- // How Much Power Is On Y
            ["Vel_Z"] = (50) -- // How Much Power Is On Z
        }
    },
    ["Esp"] = {
        ["Enabled"] = (true), -- // Enable / Disable Esp
        ["UseEspKeyBind"] = (true), -- // Enable / Disable EspKey
        ["EspKey"] = ("T"), -- // Key To Enable / Disable Esp
        ["HoldMode"] = (false), -- // Enables While Only Holding The Key
        
        ["TextSize"] = (16), -- // How Big The Text Is
        
        ["Name"] = {["Enabled"] = (true), ["OutLine"] = (true), ["Color"] = (Color3.fromRGB(255, 255, 255))}, -- // Shows Text Of The Targets Name
        ["Cheater"] = {["Enabled"] = (true), ["Suspicious"] = (true), ["OutLine"] = (true), ["Color"] = (Color3.fromRGB(255, 0, 0))}, -- // Shows Box Around The Target
        ["Box"] = {["Enabled"] = (false), ["OutLine"] = (false), ["Color"] = (Color3.fromRGB(255, 255, 255))}, -- // Shows Box Around The Target
        
        ["HealthBar"] = {["Enabled"] = (false), ["OutLine"] = (false), ["Color"] = (Color3.fromRGB(0, 255, 0)), ["HealthColor"] = (true)}, -- // Shows An Health Bar On Target. If The Player Is Low The Bar Is Gonna Shrink
        ["HealthText"] = {["Enabled"] = (true), ["OutLine"] = (true), ["Color"] = (Color3.fromRGB(0, 255, 0)), ["HealthColor"] = (true)}, -- // Shows An Text How Much Health Target Has
        
        ["ArmorBar"] = {["Enabled"] = (false), ["OutLine"] = (false), ["Color"] = (Color3.fromRGB(0, 189, 255))}, -- // Shows An Armor Bar On Target. If The Player Armor Is Low The Bar Is Gonna Shrink
        ["ArmorText"] = {["Enabled"] = (true), ["OutLine"] = (true), ["Color"] = (Color3.fromRGB(0, 189, 255))}, -- // Shows An Text How Much Amor Target Has
        
        ["Distance"] = {["Enabled"] = (true), ["OutLine"] = (true), ["Color"] = (Color3.fromRGB(255, 255, 255))}, -- // Shows Targets Distance Between You And The Target
        ["Tool"] = {["Enabled"] = (false), ["OutLine"] = (false), ["Color"] = (Color3.fromRGB(255, 255, 255))}, -- // Shows Targets Distance Between You And The Target
        ["Flags"] = {["Enabled"] = (false), ["WalkingState"] = (false), ["DesyncState"] = (false), ["OutLine"] = (false), ["Color"] = (Color3.fromRGB(255, 255, 255))}, -- // Show States For Walking Or Desyncing
        ["Tracer"] = {["Enabled"] = (false), ["Method"] = ("Mouse"), ["Thickness"] = (1), ["Color"] = (Color3.fromRGB(255, 255, 255))}, -- // Shows A Line That Goes To The Player (Mouse, Screen)
        
        ["CrewColor"] = {["Enabled"] = (false), ["Color"] = (Color3.fromRGB(0, 255, 0))}, -- // The Box Will Change Color If The Player Is The Same Crew As You
        ["TargetColor"] = {["Enabled"] = (false), ["Color"] = (Color3.fromRGB(255, 0, 0))} -- // The Box Will Change Color When You Have An Target
    }
}

-- // Mouse Keys At https://create.roblox.com/docs/reference/engine/enums/UserInputType
-- // Hot Key At https://create.roblox.com/docs/reference/engine/enums/KeyCode

-- // Variables
getgenv().SpoofLoaded = true
local SpoofLogo, GetTime = game:HttpGet("https://i.ibb.co/7zCf4TZ/XDD.png"), os.clock()

local NoclipMacro, Macro, PanicMode, TriggerBot, Desync, FreezePos, FrameSkip, FakeSpike = false, false, false, false, false, false, false, false
local ClosestPointCF, ToolConnection, SilentTarget, AimTarget, ForceLock, keybindTime, LastStutter = nil, nil, nil, nil, nil, 0, tick()
local SmoothingFactor, PositionData, PositionData2, CurrentIndex, CurrentIndex2, CurrentVelocity, CurrentVelocity2 = 6, {}, {}, 1, 1, Vector3.zero, Vector3.zero

local Script = {Functions = {}, Friends = {}, Drawing = {}, EspPlayers = {}, NotifyNote = {}, BeizerManager = {}, BeizerCurve = {}, PanicModeSaves = {}, SavedValue = {}}

local Saves = {ShotCheck = {}, CharCheck = {}, AddedCheck = {}}
local Detection = {OldAmmo = {}, Suspicious = {}, NewBullets = nil}

local Players, Client, Mouse, RS, Camera, GuiS, Uis, Tween = game:GetService("Players"), game:GetService("Players").LocalPlayer, game:GetService("Players").LocalPlayer:GetMouse(), game:GetService("RunService"), game:GetService("Workspace").CurrentCamera, game:GetService("GuiService"), game:GetService("UserInputService"), game:GetService("TweenService")
local Text_1, Text_2, Text_3, Text_4, Text_5, Text_6, Text_7 = tostring(math.random(Spoof.MemorySpoofer.Lowest, Spoof.MemorySpoofer.Maximum)), tostring("." .. math.random(1, 99) .. " MB"), tostring(math.random(Spoof.MemorySpoofer.Lowest, Spoof.MemorySpoofer.Maximum)), tostring("." .. math.random(1, 99) .. " MB"), tostring(math.random(Spoof.MemorySpoofer.Lowest, Spoof.MemorySpoofer.Maximum)), tostring("."..math.random(1, 999)), tostring("."..math.random(1, 999))

Script.SavedValue.SilentPart = Spoof.Silent.Part
Script.SavedValue.AimAssistSmoothX = Spoof.AimAssist.Smoothness_X
Script.SavedValue.AimAssistSmoothY = Spoof.AimAssist.Smoothness_Y
Script.SavedValue.ShakeX = Spoof.AimAssist.Shake.Shake_X
Script.SavedValue.ShakeY = Spoof.AimAssist.Shake.Shake_Y
Script.SavedValue.ShakeZ = Spoof.AimAssist.Shake.Shake_Z

Script.BeizerCurve.Offset = Vector2.new(0,0)

-- // Using Thise For TweenService Support + Im 2 Lazy
local SilentFovRadius = Instance.new("NumberValue")
SilentFovRadius.Name = "DevConsole"
SilentFovRadius.Parent = nil
SilentFovRadius.Value = Spoof.Silent.Fov.Radius

-- // Main Intro Local
if Spoof.Options.Intro then
    local Flash = Instance.new("ColorCorrectionEffect")
    local Blur = Instance.new("BlurEffect")
    local Gui = Instance.new("ScreenGui")
    local Image = Instance.new("ImageLabel")
    
    Flash.Parent = game.Lighting

    Blur.Parent = game.Lighting
    Blur.Size = 0
    
    Gui.Name = "RobloxGui"
    Gui.Parent = game.CoreGui
    Gui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
    
    Image.Parent = Gui
    Image.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
    Image.BackgroundTransparency = 1.000
    Image.Position = UDim2.new(0.405, 0, 0.405, 0)
    Image.Size = UDim2.new(0.17, 0, 0.27, 0)
    Image.ImageTransparency = 1
    Image.Image = "rbxassetid://79933306797394"
    
    local Create = Tween:Create(Blur, TweenInfo.new(1.5, Enum.EasingStyle.Cubic, Enum.EasingDirection.Out), {Size = 50})
    Create:Play()
    Create.Completed:Wait()
    local Create2 = Tween:Create(Image, TweenInfo.new(1, Enum.EasingStyle.Cubic, Enum.EasingDirection.Out), {ImageTransparency = 0.2})
    Create2:Play()
    Create2.Completed:Wait()
    local Create3 = Tween:Create(Image, TweenInfo.new(0.3, Enum.EasingStyle.Bounce, Enum.EasingDirection.Out), {Size = UDim2.new(0.15, 0, 0.25, 0)})
    Create3:Play()
    local Create4 = Tween:Create(Image, TweenInfo.new(0.3, Enum.EasingStyle.Bounce, Enum.EasingDirection.Out), {Position = UDim2.new(0.415, 0, 0.415, 0)})
    Create4:Play()
    Flash.TintColor = Color3.fromRGB(223, 91, 91)
    Tween:Create(Flash, TweenInfo.new(0.7), {TintColor = Color3.fromRGB(255, 255, 255)}):Play()
    task.wait(1)
    Tween:Create(Image, TweenInfo.new(3, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {ImageTransparency = 1}):Play()
    local Create5 = Tween:Create(Blur, TweenInfo.new(3, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {Size = 0})
    Create5:Play()
    Create5.Completed:Wait()
    
    Gui:Destroy()
    Flash:Destroy()
    Blur:Destroy()
end

-- // Low Gfx Function
if Spoof.Options.AutoLowGfx then
    for _, v in pairs(game:GetService("Workspace"):GetDescendants()) do
        if v:IsA("BasePart") and not v.Parent:FindFirstChild("Humanoid") then
            v.Material = Enum.Material.SmoothPlastic
            if v:IsA("Texture") then
                v:Destroy()
            end
        end
    end
end

-- // BoomBox Mute Function
if Spoof.Options.MuteBoomBox then
    for _, v in pairs(game:GetService("Workspace"):GetDescendants()) do
        if v:IsA("Sound") and not (v.Name == "ShootSound" or v.Name == "NoAmmo") then
            v.Volume = 0
        end
    end
end

-- // Seat Remove Function
if Spoof.Options.RemoveSeats then
    for _, v in pairs(game:GetService("Workspace"):GetDescendants()) do
        if v:IsA("Seat") then
            v:Destroy()
        end
    end
end

-- // The Gui V2. Not Giving Away

-- // Drawing For AimAssist, SilentAim And Desync Dot
Script.Drawing.SilentCircle = Drawing.new("Circle")
Script.Drawing.SilentCircle.Color = Color3.new(1,1,1)
Script.Drawing.SilentCircle.Thickness = 1
Script.Drawing.SilentCircle.NumSides = 128

Script.Drawing.AimAssistCircle = Drawing.new("Circle")
Script.Drawing.AimAssistCircle.Color = Color3.new(1,1,1)
Script.Drawing.AimAssistCircle.Thickness = 1
Script.Drawing.AimAssistCircle.NumSides = 128

Script.Drawing.DesyncCircle = Drawing.new("Circle")
Script.Drawing.DesyncCircle.Color = Spoof.Desync.Visualize.Color
Script.Drawing.DesyncCircle.NumSides = 128
Script.Drawing.DesyncCircle.Transparency = 1
Script.Drawing.DesyncCircle.Radius = Spoof.Desync.Visualize.Radius
Script.Drawing.DesyncCircle.Filled = true
Script.Drawing.DesyncCircle.Visible = false

-- // Checks If The Player Is Alive
Script.Functions.Alive = function(Plr)
    return (Plr and Plr.Character and Plr.Character:FindFirstChild("Humanoid") and Plr.Character:FindFirstChild("HumanoidRootPart")) and true or false
end

-- // Checks If Player Is On Your Screen
Script.Functions.OnScreen = function(Object)
    local _, OnScreen = Camera:WorldToScreenPoint(Object.Position)
    return OnScreen
end

-- // Gets The Fov Method
Script.Functions.GetFovPosition = function()
    if Spoof.Silent.Fov.Method == ("Screen") then
        return Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2)
    else
        return Vector2.new(Mouse.X, Mouse.Y)
    end
end

-- // Gets Magnitude From Part Position And Mouse
Script.Functions.GetMagnitudeFromMouse = function(Part)
    local PartPos, OnScreen = Camera:WorldToScreenPoint(Part.Position)
    if OnScreen then
        local GetScreenPos = Script.Functions.GetFovPosition()
        local Magnitude = ((Vector2.new(PartPos.X, PartPos.Y) - GetScreenPos) - Spoof.Silent.Fov.Offset).Magnitude
        return Magnitude
    end
    return math.huge
end

-- // Makes Random Number With Vector3 
Script.Functions.RandomVec3 = function(Number, Multi)
    return (Vector3.new(math.random(-Number, Number), math.random(-Number, Number), math.random(-Number, Number)) * Multi or 1)
end

-- // Checks If The Player Is Behind A Wall Or Something Else
Script.Functions.WallCheck = function(Pos, PartDescendant)
    local Character = Client.Character
    local Origin = Camera.CFrame.Position

    local RayCastParams = RaycastParams.new()
    RayCastParams.FilterType = Enum.RaycastFilterType.Blacklist
    RayCastParams.FilterDescendantsInstances = {Character, Camera}

    local Result = Workspace.Raycast(Workspace, Origin, Pos - Origin, RayCastParams)
    
    if (Result) then
        local PartHit = Result.Instance
        local Visible = (not PartHit or Instance.new("Part").IsDescendantOf(PartHit, PartDescendant))
        
        return Visible
    end
    return false
end

-- // Random Number To Compare
Script.Functions.CalculateChance = function(Percentage)
    Percentage = math.floor(Percentage)
    return math.random(0, 99) < Percentage
end

-- // Check If Crew Folder Is A Thing
Script.Functions.FindCrew = function(Plr)
	if Plr:FindFirstChild("DataFolder") and Plr.DataFolder:FindFirstChild("Information") and Plr.DataFolder.Information:FindFirstChild("Crew") and Client:FindFirstChild("DataFolder") and Client.DataFolder:FindFirstChild("Information") and Client.DataFolder.Information:FindFirstChild("Crew") then
        if Client.DataFolder.Information:FindFirstChild("Crew").Value ~= nil and Plr.DataFolder.Information:FindFirstChild("Crew").Value ~= nil and Plr.DataFolder.Information:FindFirstChild("Crew").Value ~= ("") and Client.DataFolder.Information:FindFirstChild("Crew").Value ~= ("") then 
			return true
		end
	end
	return false
end

-- // Clears AnyThing In The Console
Script.Functions.ClearConsole = function()
    coroutine.resume(coroutine.create(function()
        local DevConsole = game:GetService("CoreGui"):WaitForChild("DevConsoleMaster")
        local DevWindow = DevConsole:WaitForChild("DevConsoleWindow")
        local DevUI = DevWindow:WaitForChild("DevConsoleUI")
        local MainView = DevUI:WaitForChild("MainView")
        local ClientLog = MainView:WaitForChild("ClientLog")
        for _, v in pairs(ClientLog:GetChildren()) do
            if v:IsA("GuiObject") and v.Name == v.Name:match("%d+") then
                v:Destroy()
            end
        end
    end))
end

-- // Calculates The Velocity
Script.Functions.GetVelocity = function(PositionData)
	local TotalVelocity = 0
	local AveragePosition = Vector3.zero
	local AverageTime = 0
	local GetData = #PositionData
	if GetData == 0 then
		return AveragePosition, AverageTime
	end
	for i = 1, GetData do
		local Data = PositionData[i]
		if Data and Data.Position then
			local Velocity = SmoothingFactor - i + 1
			AveragePosition = AveragePosition + (Data.Position * Velocity)
			AverageTime = AverageTime + (Data.Time * Velocity)
			TotalVelocity = TotalVelocity + Velocity
		end
	end
	AveragePosition = AveragePosition / TotalVelocity
	AverageTime = AverageTime / TotalVelocity
	return AveragePosition, AverageTime
end

-- // Smoothness The Velocity Out
Script.Functions.ComPlexVelocity = function(Plr, CurrentPos, Mode)
	local GetTick = tick()
    local GetPos = CurrentPos

    -- // Fixes Calculating The Wrong Position
    if Mode then
        if PositionData2[CurrentIndex2] and PositionData2[CurrentIndex2].Target and tostring(Plr) ~= PositionData2[CurrentIndex2].Target then
            PositionData2[CurrentIndex2] = {Target = tostring(Plr), Position = GetPos, Time = GetTick}
            return Vector3.zero
        end
    else
        if PositionData[CurrentIndex] and PositionData[CurrentIndex].Target and tostring(Plr) ~= PositionData[CurrentIndex].Target then
            PositionData[CurrentIndex] = {Target = tostring(Plr), Position = GetPos, Time = GetTick}
            return Vector3.zero
        end
    end

    if Mode then
    	PositionData2[CurrentIndex2] = {Target = tostring(Plr), Position = GetPos, Time = GetTick}
    	CurrentIndex2 = (CurrentIndex2 % SmoothingFactor) + 1
    	local AveragePosition, AverageTime = Script.Functions.GetVelocity(PositionData2)
    	local PreviousData = PositionData2[CurrentIndex2]
    	if PreviousData and PreviousData.Position then
    		local Velocity = (GetPos - PreviousData.Position) / (GetTick - PreviousData.Time)
    		return Velocity
    	end
    else
    	PositionData[CurrentIndex] = {Target = tostring(Plr), Position = GetPos, Time = GetTick}
    	CurrentIndex = (CurrentIndex % SmoothingFactor) + 1
    	local AveragePosition, AverageTime = Script.Functions.GetVelocity(PositionData)
    	local PreviousData = PositionData[CurrentIndex]
    	if PreviousData and PreviousData.Position then
    		local Velocity = (GetPos - PreviousData.Position) / (GetTick - PreviousData.Time)
    		return Velocity
    	end
    end
    return Vector3.zero
end

-- // Changes The Mouse Position
Script.Functions.MouseOffset = function(self, X, Y)
    local NewPosition = Vector2.new(X, Y) - Spoof.Silent.Fov.Offset
    mousemoveabs(NewPosition.X, NewPosition.Y)
end

-- // Splits The Gun Name And Splits []
Script.Functions.GetGunName = function(Name)
    local split = string.split(string.split(Name, "[")[2], "]")[1]
    return split
end

-- // Gets Current Gun
Script.Functions.GetCurrentWeaponName = function()
    if Client.Character and Client.Character:FindFirstChildWhichIsA("Tool") then
       local Tool =  Client.Character:FindFirstChildWhichIsA("Tool")
       if string.find(Tool.Name, "%[") and string.find(Tool.Name, "%]") and not string.find(Tool.Name, "Wallet") and not string.find(Tool.Name, "Phone") then
          return Script.Functions.GetGunName(Tool.Name)
       end
    end
    return nil
end

-- // Drawing Function With Property Attached
Script.Functions.NewDrawing = function(Type, Properties)
    local NewDrawing = Drawing.new(Type)
    for i, v in next, Properties or {} do
        NewDrawing[i] = v
    end
    return NewDrawing
end

-- // Draws For The New Players Joining For Esp
Script.Functions.NewPlayer = function(Plr)
    Script.EspPlayers[Plr] = {
        Name = Script.Functions.NewDrawing("Text", {Color = Color3.fromRGB(255,2550, 255), Outline = true, Visible = false, Center = true, Size = 13, Font = 0}),
        
        BoxOutline = Script.Functions.NewDrawing("Square", {Color = Color3.fromRGB(0, 0, 0), Thickness = 3, Visible = false}),
        Box = Script.Functions.NewDrawing("Square", {Color = Color3.fromRGB(255, 255, 255), Thickness = 1, Visible = false}),
        
        HealthBarOutline = Script.Functions.NewDrawing("Line", {Color = Color3.fromRGB(0, 0, 0), Thickness = 3, Visible = false}),
        HealthBar = Script.Functions.NewDrawing("Line", {Color = Color3.fromRGB(0, 255, 0), Thickness = 1, Visible = false}),
        HealthText = Script.Functions.NewDrawing("Text", {Color = Color3.fromRGB(0, 255, 0), Outline = true, Visible = false, Center = true, Size = 13, Font = 0}),
        
        ArmorBarOutline = Script.Functions.NewDrawing("Line", {Color = Color3.fromRGB(0, 0, 0), Thickness = 3, Visible = false}),
        ArmorBar = Script.Functions.NewDrawing("Line", {Color = Color3.fromRGB(0, 255, 0), Thickness = 1, Visible = false}),
        ArmorText = Script.Functions.NewDrawing("Text", {Color = Color3.fromRGB(0, 255, 0), Outline = true, Visible = false, Center = true, Size = 13, Font = 0}),
        
        Distance = Script.Functions.NewDrawing("Text", {Color = Color3.fromRGB(255, 255, 255), Outline = true, Visible = false, Center = true, Size = 13, Font = 0}),
        
        Tool = Script.Functions.NewDrawing("Text", {Color = Color3.fromRGB(255, 255, 255), Outline = true, Visible = false, Center = true, Size = 13, Font = 0}),
        
        Flag = Script.Functions.NewDrawing("Text", {Color = Color3.fromRGB(255, 255, 255), Outline = true, Visible = false, Center = true, Size = 13, Font = 0}),
        
        Tracer = Script.Functions.NewDrawing("Line", {Color = Color3.fromRGB(255, 255, 244), Thickness = 1, Visible = false}),
    }
end

-- // The Notification Ui Function
Script.Functions.CreateNotification = function(Text, CustomColor)
	local Gap = 25
	local Width = 18
	local Alpha = 255
	local Time = 0
	local EStep = 0
	local EEStep = 0.02
	local InSety = 0

	local Note = {
		Enabled = true,
		TargetPos = Vector2.new(50, 33),
		Size = Vector2.new(200, Width),
		
		Drawings = {
		    Outline = Script.Functions.NewDrawing("Square", {Size = Vector2.new(202, Width + 2), Filled = false, Visible = true, Thickness = 1, Position = Vector2.new(), Color = Color3.new(0, 0, 0)}),
			Fade = Script.Functions.NewDrawing("Square", {Size = Vector2.new(202, Width + 2), Filled = false, Visible = true, Thickness = 1, Position = Vector2.new(), Color = Color3.new(0, 0, 0)}),
		},
        
		Remove = function(self, Part)
			if Part.Position.x < Part.Size.x then
				for _, v in pairs(self.Drawings) do
					v:Remove()
					v = false
				end
				self.Enabled = false
			end
		end,

		Update = function(self, Number, ListLength, Dt)
			local Pos = self.TargetPos
			local indexOffset = (ListLength - Number) * Gap
            
			if InSety < indexOffset then
				InSety = InSety - (InSety - indexOffset) * 0.2
			else
				InSety = indexOffset
			end

			local Size = self.Size
			local LastPos = Vector2.new(Pos.x - Size.x / Time - (Alpha / 255 * -Size.x + Size.x), Pos.y + InSety)
			self.Pos = LastPos
			
			local CurrentPos = {
				X = math.ceil(LastPos.x),
				Y = math.ceil(LastPos.y),
				W = math.floor(Size.x - (255 - Alpha) / (255 * 70)),
				H = Size.y,
			}
			
			local Fade = math.min(Time * 12, Alpha)
			Fade = Fade > 255 and 255 or Fade < 0 and 0 or Fade

			if self.Enabled then
				local LineRepeat = 1
				for i, v in pairs(self.Drawings) do
					v.Transparency = Fade / 255
					if type(i) == ("number") then
						v.Position = Vector2.new(CurrentPos.X + 1, CurrentPos.Y + i)
						v.Size = Vector2.new(CurrentPos.W - 2, 1)
					elseif i == ("Image") then
					    v.Position = LastPos + Vector2.new(6, 2)
					elseif i == ("Text") then
						v.Position = LastPos + Vector2.new(25, 2)
					elseif i == ("Outline") then
						v.Position = Vector2.new(CurrentPos.X, CurrentPos.Y)
						v.Size = Vector2.new(CurrentPos.W, CurrentPos.H)
					elseif i == ("Fade") then
						v.Position = Vector2.new(CurrentPos.X - 1, CurrentPos.Y - 1)
						v.Size = Vector2.new(CurrentPos.W + 2, CurrentPos.H + 2)
						local T = (200 - Fade) / 255 / 3
						v.Transparency = T < 0.4 and 0.4 or T
					elseif i:find("line") then
						v.Position = Vector2.new(CurrentPos.X + LineRepeat, CurrentPos.Y + 1)
						LineRepeat = LineRepeat + 1
					end
				end

				Time = Time + EStep * Dt * 128 
				EStep = EStep + EEStep * Dt * 64
			end
		end,

		Fade = function(self, Number, Len, Dt)
			if self.Pos.x > self.TargetPos.x - 0.2 * Len or self.Fading then
				if not self.Fading then
					EStep = 0
				end
				self.Fading = true
				Alpha = Alpha - EStep / 4 * Len * Dt * 50
				EEStep = EEStep + 0.01 * Dt * 100
			end
			
            if Alpha <= 0 then
				self:Remove(self.Drawings[1])
			end
		end,
	}

    for i = 1, Note.Size.y - 2 do
    	local X = 0.28 - i / 80
    	Note.Drawings[i] = Script.Functions.NewDrawing("Square", {Size = Vector2.new(200, 1), Filled = true, Visible = true, Thickness = 1, Position = Vector2.new(), Color = Color3.new(X, X, X)})
    end
    
    local C = CustomColor or Color3.fromRGB(206, 67, 67)
    Note.Drawings.Text = Script.Functions.NewDrawing("Text", {Size = 13,Text = Text , Visible = true, Center = false, Outline = true, Font = 2, Position = Vector2.new(), Color = Color3.new(1, 1, 1)})
    Note.Drawings.Image = Script.Functions.NewDrawing("Image", {Size = Vector2.new(15,15), Visible = true, Position = Vector2.new(), Data = SpoofLogo})

    if Note.Drawings.Text.TextBounds.x + 7 > Note.Size.x then
    	Note.Size = Vector2.new(Note.Drawings.Text.TextBounds.x + 27, Note.Size.y)
    end
    
    Note.Drawings.line = Script.Functions.NewDrawing("Square", {Size = Vector2.new(1, Note.Size.y - 2), Filled = true, Visible = true, Thickness = 1, Position = Vector2.new(), Color = C})
    Note.Drawings.line1 = Script.Functions.NewDrawing("Square", {Size = Vector2.new(1, Note.Size.y - 2), Filled = true, Visible = true, Thickness = 1, Position = Vector2.new(), Color = C})
    Script.NotifyNote[#Script.NotifyNote + 1] = Note
end

-- // Gets The Closest Part Of The Character To Cursor
Script.Functions.GetClosestBodyPart = function(Char)
    local Distance = math.huge
    local ClosestPart = nil
    local Filterd = {}

    local Parts = Char:GetChildren()
    for _, v in pairs(Parts) do
        if Spoof.Silent.UseWhitelistedParts and table.find(Spoof.Silent.WhitelistedPart, v.Name) == nil then continue end
        if v:IsA("MeshPart") and v:IsA("BasePart") and Script.Functions.OnScreen(v) then
            table.insert(Filterd, v)
            for _, v in pairs(Filterd) do                
                local Magnitude = Script.Functions.GetMagnitudeFromMouse(v)
                if Magnitude < Distance then
                    ClosestPart = v
                    Distance = Magnitude
                end
            end
        end
    end
    return ClosestPart
end

-- // Gets An Random Part Of The Character
Script.Functions.GetRandomBodyPart = function(Char)
    local CurrentParts = {}
    local Parts = Char:GetChildren()
    
    for _, v in pairs(Parts) do
        if Spoof.Silent.UseWhitelistedParts and table.find(Spoof.Silent.WhitelistedPart, v.Name) == nil then continue end
        if v:IsA("MeshPart") and v:IsA("BasePart") and Script.Functions.OnScreen(v) then
            table.insert(CurrentParts, v)
        end
    end
    
    local Randomize = CurrentParts[math.random(1, #CurrentParts)]
    return Randomize
end

-- // Gets The Closest Point From Cursor
Script.Functions.GetClosestPointOnPart = function(Part)
    local Transform = Part.CFrame:PointToObjectSpace(Mouse.Hit.Position)
    return Part.CFrame * Vector3.new(
        math.clamp(Transform.X, - Part.Size.X % (Spoof.Silent.ClosestPointScale / 2), Part.Size.X % (Spoof.Silent.ClosestPointScale / 2)), 
        math.clamp(Transform.Y, - Part.Size.Y % (Spoof.Silent.ClosestPointScale / 2), Part.Size.Y % (Spoof.Silent.ClosestPointScale / 2)), 
        math.clamp(Transform.Z, - Part.Size.Z % (Spoof.Silent.ClosestPointScale / 2), Part.Size.Z % (Spoof.Silent.ClosestPointScale / 2))
    )
end

-- // Mod Detection Function
Script.Functions.CheckIfMod = function(Plr)
    if Spoof.ModDetection.Enabled then
        if (game:GetService("MarketplaceService"):GetProductInfo(game.PlaceId).Creator.CreatorType == "Group" and true or false) == true then
            local GetId = game:GetService("GroupService"):GetGroupInfoAsync(game:GetService("MarketplaceService"):GetProductInfo(game.PlaceId).Creator.CreatorTargetId).Id
            local GroupId = tonumber(GetId)
            
            if Plr:IsInGroup(GroupId) and Plr:GetRankInGroup(GroupId) > Spoof.ModDetection.Rank then
                if Spoof.ModDetection.Method == ("Kick") then 
                    task.wait(Spoof.ModDetection.Delay)
                    Client:Kick("Detected Moderator / Admin: " .. tostring(Plr))
                elseif Spoof.ModDetection.Method == ("Notification") then
                    Script.Functions.CreateNotification("Detected Moderator / Admin: " .. tostring(Plr), Color3.fromRGB(206, 67, 67))
                end
            end
        end
    end
end

-- // Gets The Closest Player For Cursor (Silent Aim)
Script.Functions.GetClosestPlayer = function(Mode)
    local Target, Closest, HitChance = nil, math.huge, Script.Functions.CalculateChance(Spoof.Silent.HitChance)
    
    if not HitChance then
        return nil
    end
    if Mode then
        for _, v in pairs(Players:GetPlayers()) do
            if v.Character and v ~= Client and v.Character:FindFirstChild("HumanoidRootPart") then
                if not Script.Functions.OnScreen(v.Character.HumanoidRootPart) then continue end
                if Spoof.UniversalCheck.WallCheck and not Script.Functions.WallCheck(v.Character.HumanoidRootPart.Position, v.Character) then continue end
                local Distance = Script.Functions.GetMagnitudeFromMouse(v.Character.HumanoidRootPart)
                if (Spoof.Silent.ForceLock and Script.Drawing.SilentCircle.Radius + (Distance * 0.3) < Distance) then continue end
                if Distance < Closest then
                    Closest = Distance
                    Target = v
                end
            end
        end
    else
        if Spoof.Silent.ForceLock_AimAssistTarget and Script.Functions.Alive(AimTarget) then
            Target = AimTarget
        elseif Spoof.Silent.ForceLock_AimAssistTarget == false then
            Target = ForceLock
        end
    end
    
    if Script.Functions.Alive(Target) then
        local Velocity = Script.Functions.ComPlexVelocity(Target, Target.Character.HumanoidRootPart.Position, false)
        CurrentVelocity = Velocity
    else
        CurrentVelocity = Vector3.zero
    end

    return Target
end

-- // Target Check For Silent Aim Target
Script.Functions.SilentCheck = function(Plr)
    if Spoof.UniversalCheck.KoCheck and Plr.Character:FindFirstChild("BodyEffects") then
        local KoCheck = false
        if Plr.Character.BodyEffects:FindFirstChild("K.O") then
            KoCheck = Plr.Character.BodyEffects["K.O"].Value
        elseif Plr.Character.BodyEffects:FindFirstChild("KO") then
            KoCheck = Plr.Character.BodyEffects.KO.Value
        end
        local Grabbed = Plr.Character:FindFirstChild("GRABBING_CONSTRAINT") ~= nil
        if KoCheck or Grabbed then 
            return false 
        end
    end
    if Spoof.UniversalCheck.FriendCheck and table.find(Script.Friends, Plr) then
        return false  
    end
    if Spoof.UniversalCheck.TargetDeathCheck and Plr.Character:FindFirstChild("Humanoid") and Plr.Character.Humanoid.health < 4 then
        return false 
    end
    if Spoof.UniversalCheck.ForceFieldCheck and Plr.Character:FindFirstChildOfClass("ForceField") then
        return false
    end
    if Spoof.UniversalCheck.InVisibleCheck and Plr.Character:FindFirstChild("Head") and Plr.Character.Head.Transparency > 0.5 then
        return false  
    end
    if Spoof.UniversalCheck.CrewCheck and Script.Functions.FindCrew(Plr) and Plr.DataFolder.Information:FindFirstChild("Crew").Value ~= Client.DataFolder.Information:FindFirstChild("Crew").Value then 
        return false  
    end
    if Spoof.UniversalCheck.TeamCheck and Client.Team ~= nil and Plr.Team ~= nil and Plr.Team == Client.Team then 
        return false 
    end
    return true
end

-- // Error Detection Function

-- // Cheater Detection Function

-- // Gets The Closest Part From The Target And Checks If AimAssist Is On To Save Fps
Script.Functions.GetClosestPartMethod = function(Plr)
    local ClosestPart, PartClosest, Filterd = nil, math.huge, {}
    
    if Spoof.Silent.LegitMode then
        if Spoof.Silent.ClosestPart == false and Plr.Character:FindFirstChild(Spoof.Silent.Part) then
            return Plr.Character[Spoof.Silent.Part]
        elseif AimTarget and Spoof.AimAssist.ClosestPart and Plr.Character:FindFirstChild(Spoof.AimAssist.Part) then
            return Plr.Character[Spoof.AimAssist.Part]
        end
        return nil
    end
    
    if Script.Functions.Alive(Plr) then
        if SilentTarget.Character.Humanoid:GetState() == Enum.HumanoidStateType.Freefall then
            local AirHitChance = Script.Functions.CalculateChance(Spoof.Silent.AirHitChance)
            if not AirHitChance then
                return nil
            end
            if Spoof.Silent.UseAirPart and SilentTarget.Character:FindFirstChild(Spoof.Silent.AirPart) then
                return SilentTarget.Character[Spoof.Silent.AirPart]
            end
        else
            if Spoof.Silent.UseAirPart and SilentTarget.Character:FindFirstChild(Script.SavedValue.SilentPart) then
                return SilentTarget.Character[Script.SavedValue.SilentPart]
            end
        end
        
        if Spoof.Silent.ClosestPart == false and Plr.Character:FindFirstChild(Spoof.Silent.Part) then
            local PartDistance = Script.Functions.GetMagnitudeFromMouse(Plr.Character[Spoof.Silent.Part])

            if (Spoof.Silent.ForceLock == false and Script.Drawing.SilentCircle.Radius + 4 > PartDistance) or Spoof.Silent.ForceLock == true then
                return Plr.Character[Spoof.Silent.Part]
            end
            return nil
        end
        
        local Parts = Plr.Character:GetChildren()
        for _, v in pairs(Parts) do
            if Spoof.Silent.UseWhitelistedParts and table.find(Spoof.Silent.WhitelistedPart, v.Name) == nil then continue end
            if v:IsA("MeshPart") and v:IsA("BasePart") and Script.Functions.OnScreen(v) then
                table.insert(Filterd, v)
                for _, v in pairs(Filterd) do
                    local Mag = Script.Functions.GetMagnitudeFromMouse(v)
                    if (Spoof.Silent.ForceLock == false and Spoof.Silent.LegitMode == false and Script.Drawing.SilentCircle.Radius + 4 < Mag) then continue end
                    if Mag < PartClosest then
                        ClosestPart = v
                        PartClosest = Mag
                    end
                end
            end
        end
        
        return ClosestPart
    end
    return nil
end

-- // Gets Closest Player From Mouse For AimAssist
Script.Functions.GetClosestPlayer2 = function()
    local Target, Distance, Closest = nil, nil, math.huge
    
    for _, v in pairs(Players:GetPlayers()) do
        if v.Character and v ~= Client and v.Character:FindFirstChild("HumanoidRootPart") then
            if not Script.Functions.OnScreen(v.Character.HumanoidRootPart) then continue end
            if Spoof.UniversalCheck.WallCheck and not Script.Functions.WallCheck(v.Character.HumanoidRootPart.Position, v.Character) then continue end
        	if Spoof.UniversalCheck.InVisibleCheck and v.Character:FindFirstChild("Head") then
        		if v.Character.Head.Transparency > 0.5 then
        			continue
        		end
        	end
            if Spoof.UniversalCheck.ForceField and not v.Character:FindFirstChildOfClass("ForceField") then
                continue
            end
        	if Spoof.UniversalCheck.CrewCheck and Script.Functions.FindCrew(v) and v.DataFolder.Information:FindFirstChild("Crew").Value ~= Client.DataFolder.Information:FindFirstChild("Crew").Value then
        		continue
        	end
            if Spoof.UniversalCheck.TeamCheck and Client.Team ~= nil and v.Team ~= nil and v.Team ~= Client.Team then
                continue
            end
            if Spoof.UniversalCheck.FriendCheck and table.find(Script.Friends, v) ~= nil then
                continue
            end
            local Distance = Script.Functions.GetMagnitudeFromMouse(v.Character.HumanoidRootPart)
            if Distance < Closest then
                if (Spoof.AimAssist.UseCircleRadius and Script.Drawing.AimAssistCircle.Radius + (Distance * 0.3) < Distance) then continue end
                Closest = Distance
                Target = v
            end
        end
    end

    return Target
end

-- // Main Functions For The BeizerManager Functions
Script.BeizerManager.__index = Script.BeizerManager

-- // The Main Function That Makes It Work
Script.BeizerManager.New = function()
    local self = setmetatable({}, Script.BeizerManager)
    
    self.T = 0
    self.T_Threshold = 0.99995
    self.StartPoint = Vector2.new()
    self.EndPoint = Vector2.new()
    self.CurvePoints = {
        Vector2.new(1, 1),
        Vector2.new(1, 1)
    }
    self.Active = false
    self.Smoothness = 0.0025
    self.DrawPath = false
    self.Function = Script.Functions.MouseOffset

    self.Started = false

    return self
end

-- // Changes Current self Propertiesself.T 
Script.BeizerManager.ChangeData = function(self, Data)
    self.StartPoint = (self.GetStartPoint() or Data.StartPoint)
    self.EndPoint = self.ModifyEndPoint(Data.TargetPosition)
    self.Smoothness = Data.Smoothness or self.Smoothness
    self.CurvePoints = Data.CurvePoints or self.CurvePoints
    self.DrawPath = Data.DrawPath or self.DrawPath

    self.T = 0
    self.Active = true
end

-- // Calculates Every Points For More Accuracy
Script.BeizerManager.CubicCurve = function(T, StartPoint, EndPoint, ControlPointA, ControlPointB)
    local T1 = (1 - T)

    local A = T1^3 * StartPoint
    local B = 3 * T1^2 * T * ControlPointA
    local C = 3 * T1 * T^2 * ControlPointB
    local D = T^3 * EndPoint
    
    return A + B + C + D
end

-- // Controls And Calculates StartPoint And Other Stuff
Script.BeizerManager.DoControlPoint = function(StartPoint, EndPoint, ControlPointA, ControlPointB)
    local Change = (EndPoint - StartPoint)

    local A = StartPoint + (Change * ControlPointA)
    local B = StartPoint + (Change * ControlPointB)
    return A, B
end

-- // Draws Circle Where The CurvePosition And The Client Position
Script.BeizerManager.DrawPathFunc = function(CurvePosition, A, B)
    local Path = Script.Functions.NewDrawing("Circle", {Color = Color3.fromRGB(255, 150, 150), Radius = 2, Visible = true, Position = CurvePosition,})
    task.delay(1, function()
        Path:Remove()
    end)

    local ControlPointA = Script.Functions.NewDrawing("Circle", {Color = Color3.fromRGB(255, 150, 255), Radius = 5, Visible = true, Position = A,})
    task.delay(1, function()
        ControlPointA:Remove()
    end)

    local ControlPointB = Script.Functions.NewDrawing("Circle", {Color = Color3.fromRGB(255, 150, 255), Radius = 5, Visible = true, Position = B,})
    task.delay(1, function()
        ControlPointB:Remove()
    end)
end

-- // Changes The self For The Curving To Happend
Script.BeizerManager.DoIteration = function(self)
    if (self.Active == false) then
        return
    end
    local BeizerCurve = self.CubicCurve
    local T = self.T
    while (T <= 1 and self.Active) do RS.RenderStepped:Wait()
        T = T + self.Smoothness
        if (T >= self.T_Threshold) then
            local clampedT = math.clamp(T, 0, 1)
            local New = self.StartPoint:Lerp(self.EndPoint, clampedT)

            self:Function(New.X, New.Y)
        else
            local A, B = self.DoControlPoint(self.StartPoint, self.EndPoint, unpack(self.CurvePoints))
            local CurvePosition = BeizerCurve(T, self.StartPoint, self.EndPoint, A, B)
                
            if (self.DrawPath) then
                Script.BeizerManager.DrawPathFunc(CurvePosition, A, B)
            end
            self:Function(CurvePosition.X, CurvePosition.Y)
        end
    end
    self.Active = false
end

-- // Modifies The EndPoint Just For Double Checks
Script.BeizerManager.ModifyEndPoint = function(EndPoint)
    return EndPoint
end

-- // Starts The Motion
Script.BeizerManager.Start = function(self)
    self.Started = true

    local Thread = coroutine.resume(coroutine.create(function()
        while (self.Started) do RS.RenderStepped:Wait()
            self:DoIteration()
        end
    end))

    return Thread
end

-- // Stops The Motion
Script.BeizerManager.Stop = function(self)
    self.Started = false
end

-- // Stops The Current Motion
Script.BeizerManager.StopCurrent = function(self)
    self.Active = false
    self.T = 0
end

-- // Gets Camera Instead Of Mouse
Script.BeizerManager.CameraMode = function(self)
    self.GetStartPoint = function()
        local Pitch, Yaw, _ = Camera.CFrame:ToEulerAnglesYXZ()
        local StartPoint = Vector2.new(Pitch, Yaw)
        return StartPoint
    end

    self.ModifyEndPoint = function(EndPoint)
        local LookAtEndPoint = CFrame.lookAt(Camera.CFrame.Position, EndPoint)
        local Pitch, Yaw, _ = LookAtEndPoint:ToEulerAnglesYXZ()
        EndPoint = Vector2.new(Pitch, Yaw)
        return EndPoint
    end

    self.Function = function(self, Pitch, Yaw)
        local RotationMatrix = CFrame.fromEulerAnglesYXZ(Pitch, Yaw, 0)
        Camera.CFrame = CFrame.new(Camera.CFrame.Position) * RotationMatrix
    end

    self.DrawPathFunc = function()
        -- // Working On It
    end
end

-- // Gets Mouse Position ServerSided
Script.BeizerManager.GetStartPoint = function()
    return Uis:GetMouseLocation()
end

-- // Gets Mouse Instead Of Camera
Script.BeizerManager.MouseMode = function(self)
    self.GetStartPoint = Script.BeizerManager.GetStartPoint
    self.ModifyEndPoint = Script.BeizerManager.ModifyEndPoint
    self.Function = Script.Functions.MouseOffset
    self.DrawPathFunc = Script.BeizerManager.DrawPathFunc
end

-- // Start BeizerCurve
local ManagerA = Script.BeizerManager.New()
local ManagerB = Script.BeizerManager.New()
Script.BeizerCurve.ManagerA = ManagerA
Script.BeizerCurve.ManagerB = ManagerB

Script.BeizerCurve.AimTo = function(...)
    ManagerA:ChangeData(...)
end

Script.BeizerCurve.AimToB = function(...)
    ManagerB:ChangeData(...)
end

ManagerB:CameraMode()

ManagerB.Function = function(self, Pitch, Yaw)
    local RotationMatrix = CFrame.fromEulerAnglesYXZ(Pitch, Yaw, 0)
    Utilities.SetCameraCFrame(CFrame.new(Camera.CFrame.Position) * RotationMatrix)
end

ManagerA:Start()
ManagerB:Start()

-- // Silent Get Part Position
Script.Functions.GetPartPosition = function(Plr)
    local TargetCF = nil
    local TargetFalling = false
    local SilentPos = nil
    
    if Spoof.Silent.ClosestPoint then
        TargetCF = ClosestPointCF
    else
        if Plr.Character:FindFirstChild(Spoof.Silent.Part) then
            TargetCF = Plr.Character[Spoof.Silent.Part].Position
        end
    end

    if Spoof.Silent.AntiGroundShots and CurrentVelocity.Y < Spoof.Silent.AntiGroundActivation then
        TargetFalling = true
    end
    if TargetCF and CurrentVelocity then
        SilentPos = TargetCF
        if Spoof.Silent.PredictMovement then 
            if Spoof.Silent.BlatantMode then
                local Enabled = true
                local Mag = (Plr.Character.Humanoid.MoveDirection).Magnitude
                local SilentVel = Plr.Character.HumanoidRootPart.Velocity
                if (SilentVel).Magnitude > 100 then
                    Enabled = false
                elseif SilentVel.Y > 50 then
                    Enabled = false
                elseif SilentVel.Y < -35 then
                    Enabled = false
                elseif SilentVel.Y > 75 then
                    Enabled = false
                elseif (SilentVel).Magnitude < 1 and Mag > 0.01 then
                    Enabled = false
                elseif (SilentVel).Magnitude > 5 and Mag < 0.01 then
                    Enabled = false
                end
                if Enabled and Spoof.UniversalCheck.WallCheck_V2 and not Script.Functions.WallCheck(Plr.Character.HumanoidRootPart.Position + (SilentTarget.Character.HumanoidRootPart.Velocity * Spoof.Silent.Prediction), Plr.Character) then
                    return
                end
                if Enabled then
                    if TargetFalling then
                        SilentPos = SilentPos + (Vector3.new(SilentVel.X, (SilentVel.Y * Spoof.Silent.AntiGroundValue), SilentVel.Z) * Spoof.Silent.Prediction)
                    else
                        SilentPos = SilentPos + (SilentVel * Spoof.Silent.Prediction)
                    end
                else
                    if TargetFalling then
                        SilentPos = SilentPos + (Vector3.new(CurrentVelocity.X, (CurrentVelocity.Y * Spoof.Silent.AntiGroundValue), CurrentVelocity.Z) * Spoof.Silent.Prediction)
                    else
                        SilentPos = SilentPos + (CurrentVelocity * Spoof.Silent.Prediction)
                    end
                end
            else
                if TargetFalling then
                    SilentPos = SilentPos + (Vector3.new(CurrentVelocity.X, (CurrentVelocity.Y * Spoof.Silent.AntiGroundValue), CurrentVelocity.Z) * Spoof.Silent.Prediction)
                else
                    SilentPos = SilentPos + (CurrentVelocity * Spoof.Silent.Prediction)
                end
            end
        end
        if Spoof.Silent.Humanize then
            local HumanizeValue = Spoof.Silent.HumanizeValue 
            SilentPos = (SilentPos + Script.Functions.RandomVec3(HumanizeValue, 0.01))
        end
    end
    if SilentPos then
        if Spoof.Silent.LegitMode then
            local PartPos = Camera:WorldToScreenPoint(SilentPos)
            local GetScreenPos = Script.Functions.GetFovPosition()
            local Magnitude = (Vector2.new(PartPos.X, PartPos.Y) - GetScreenPos).Magnitude

            if (Spoof.Silent.ForceLock == false and Script.Drawing.SilentCircle.Radius + 4 > Magnitude) or Spoof.Silent.ForceLock == true then
                return SilentPos
            end
        else
            return SilentPos
        end
    end
    return nil
end

local MousePosChanger2 = nil 
MousePosChanger2 = hookmetamethod(game, "__index", function(self, Index)
    if not checkcaller() and Spoof.Silent.Enabled and Spoof.Silent.AntiAimViewer == false and self == Mouse and Script.Functions.Alive(SilentTarget) then
        if Index == ("Hit") then
            local EndPoint = Script.Functions.GetPartPosition(SilentTarget)
            if EndPoint then
                return EndPoint
            end
        elseif Index == ("Target") and SilentTarget.Character:FindFirstChild(Spoof.Silent.Part) then 
            return SilentTarget.Character[Spoof.Silent.Part]
        end
    end
    return MousePosChanger2(self, Index)
end)

-- // The AimAssist Mouse Dragging/Check Functions
Script.Functions.MouseChanger = function()
    if Spoof.AimAssist.Enabled and not Uis:GetFocusedTextBox() and Script.Functions.Alive(AimTarget) and Script.Functions.Alive(Client) and AimTarget.Character:FindFirstChild(Spoof.AimAssist.Part) then
        local EndPosition = nil
        local TargetPos = AimTarget.Character[Spoof.AimAssist.Part].Position

        if Spoof.AimAssist.ThirdPerson and Spoof.AimAssist.FirstPerson == false then
            if (Camera.Focus.p - Camera.CoordinateFrame.p).Magnitude < 1 then
                return
            end
        elseif Spoof.AimAssist.ThirdPerson == false and Spoof.AimAssist.FirstPerson then
            if (Camera.Focus.p - Camera.CoordinateFrame.p).Magnitude > 1 then
                return
            end
        end
        CurrentVelocity2 = Script.Functions.ComPlexVelocity(AimTarget, AimTarget.Character.HumanoidRootPart.Position, true)
        if CurrentVelocity2 == nil then return end
        if Spoof.AimAssist.EnableChance then
            local Chance = Script.Functions.CalculateChance(Spoof.AimAssist.Chance)
            if not Chance then
                return
            end
        end
        if Spoof.UniversalCheck.ToolOut and not Client.Character:FindFirstChildWhichIsA("Tool") then
            return
        end
        if Spoof.UniversalCheck.ForceFieldCheck and AimTarget.Character:FindFirstChildOfClass("ForceField") then
            AimTarget = nil
            CurrentVelocity2 = Vector3.zero
            return
        end
        if Spoof.AimAssist.RandomPart or Spoof.AimAssist.ClosestPart then
            if Script.Functions.OnScreen(AimTarget.Character.HumanoidRootPart) then
                if Spoof.AimAssist.RandomPart then
                    local RandomizedPart = Script.Functions.GetRandomBodyPart(AimTarget.Character)
                    if RandomizedPart ~= nil then
                        Spoof.AimAssist.Part = tostring(RandomizedPart)
                    end
                elseif Spoof.AimAssist.ClosestPart then
                    local ClosestPart = Script.Functions.GetClosestBodyPart(AimTarget.Character)
                    Spoof.AimAssist.Part = tostring(ClosestPart)
                end
            else
                if Spoof.AimAssist.Method == ("Mouse") then
                    return
                end
            end
        end
        if Spoof.UniversalCheck.ReloadCheck then
            for _, v in pairs(Client.Character.Humanoid.Animator:GetPlayingAnimationTracks()) do
                if tostring(v) == ("Animation") then
                    return
                end
            end
        end
        if Spoof.UniversalCheck.NoAmmoCheck and Client.Character:FindFirstChildWhichIsA("Tool") and Client.Character:FindFirstChildWhichIsA("Tool"):FindFirstChild("Ammo") then
            if Client.Character:FindFirstChildWhichIsA("Tool"):FindFirstChild("Ammo").Value <= 0 then
                return
            end
        end
        if Spoof.AimAssist.Advanced.WallCheck_V2 and not Script.Functions.WallCheck(AimTarget.Character.HumanoidRootPart.Position, AimTarget.Character) then 
            return
        end
        if Spoof.AimAssist.DisableOutSideCircle then
            local Magnitude = Script.Functions.GetMagnitudeFromMouse(AimTarget.Character.HumanoidRootPart)
            if (Script.Drawing.AimAssistCircle.Radius + 4) < Magnitude then
                return
            end
        end
        if Spoof.UniversalCheck.PlayerDeathCheck then
            if Client.Character.Humanoid.health < 4 then
                AimTarget = nil
                CurrentVelocity2 = Vector3.zero
                return
            end
        end
        if Spoof.UniversalCheck.KoCheck and AimTarget.Character:FindFirstChild("BodyEffects") then 
            local Grabbed = AimTarget.Character:FindFirstChild("GRABBING_CONSTRAINT") ~= nil
            local KoCheck = true
            if AimTarget.Character.BodyEffects:FindFirstChild("K.O") then
                KoCheck = AimTarget.Character.BodyEffects["K.O"].Value
            elseif AimTarget.Character.BodyEffects:FindFirstChild("KO") then
                KoCheck = AimTarget.Character.BodyEffects.KO.Value
            end
            if KoCheck or Grabbed then
                AimTarget = nil
                CurrentVelocity2 = Vector3.zero
                return
            end
        end
        if Spoof.UniversalCheck.TargetDeathCheck then
            if AimTarget.Character.Humanoid.health < 4 then
                AimTarget = nil
                CurrentVelocity2 = Vector3.zero
                return
            end
        end
        if Spoof.AimAssist.Shake.AirShake or Spoof.AimAssist.AirSmoothness then
            if AimTarget.Character.Humanoid:GetState() == Enum.HumanoidStateType.Freefall then
                if Spoof.AimAssist.AirSmoothness then
                    Spoof.AimAssist.Smoothness_X = Spoof.AimAssist.AirSmoothness_X
                    Spoof.AimAssist.Smoothness_X = Spoof.AimAssist.AirSmoothness_Y
                end
                if Spoof.AimAssist.Shake.AirShake then
                    if Spoof.AimAssist.Shake.Shake_X == Script.SavedValue.ShakeX then
                        Spoof.AimAssist.Shake.Shake_X = Spoof.AimAssist.Shake.Shake_X * (Spoof.AimAssist.Shake.AirPercentage / 100)
                    end
                    if Spoof.AimAssist.Shake.Shake_Y == Script.SavedValue.ShakeY then
                        Spoof.AimAssist.Shake.Shake_Y = Spoof.AimAssist.Shake.Shake_Y * (Spoof.AimAssist.Shake.AirPercentage / 100)
                    end
                    if Spoof.AimAssist.Shake.Shake_Z == Script.SavedValue.ShakeZ then
                        Spoof.AimAssist.Shake.Shake_Z = Spoof.AimAssist.Shake.Shake_Z * (Spoof.AimAssist.Shake.AirPercentage / 100)
                    end
                end
            else
                if Spoof.AimAssist.AirSmoothness then
                    if Spoof.AimAssist.Smoothness_X ~= Script.SavedValue.AimAssistSmoothX then
                        Spoof.AimAssist.Smoothness_X = Script.SavedValue.AimAssistSmoothX
                    end
                    if Spoof.AimAssist.Smoothness_Y ~= Script.SavedValue.AimAssistSmoothY then
                        Spoof.AimAssist.Smoothness_Y = Script.SavedValue.AimAssistSmoothY
                    end
                end
                if Spoof.AimAssist.Shake.AirShake then
                    if Spoof.AimAssist.Shake.Shake_X ~= Script.SavedValue.ShakeX then
                        Spoof.AimAssist.Shake.Shake_X = Script.SavedValue.ShakeX
                    end
                    if Spoof.AimAssist.Shake.Shake_Y ~= Script.SavedValue.ShakeY then
                        Spoof.AimAssist.Shake.Shake_Y = Script.SavedValue.ShakeY
                    end
                    if Spoof.AimAssist.Shake.Shake_Z ~= Script.SavedValue.ShakeZ then
                        Spoof.AimAssist.Shake.Shake_Z = Script.SavedValue.ShakeZ
                    end
                end
            end
        end
        
        if FrameSkip and Spoof.AimAssist.FrameSkip.TargetPart.Enabled and AimTarget.Character:FindFirstChild(Spoof.AimAssist.FrameSkip.TargetPart.Part) then
            if Spoof.AimAssist.FrameSkip.UsePrediction then
                EndPosition = AimTarget.Character[Spoof.AimAssist.FrameSkip.TargetPart.Part].Position + (CurrentVelocity2 * Spoof.AimAssist.Prediction)
            else
                EndPosition = AimTarget.Character[Spoof.AimAssist.FrameSkip.TargetPart.Part].Position
            end
        elseif FrameSkip then
            if Spoof.AimAssist.FrameSkip.UsePrediction then
                EndPosition = TargetPos + (CurrentVelocity2 * Spoof.AimAssist.Prediction)
            else
                EndPosition = TargetPos
            end
        elseif Spoof.AimAssist.PredictMovement then
            EndPosition = TargetPos + (CurrentVelocity2 * Spoof.AimAssist.Prediction)
        else
            EndPosition = TargetPos
        end

        if (EndPosition and (tick() - LastStutter) >= (Spoof.AimAssist.Advanced.Stutter / 1000)) then
            LastStutter = tick()
            if Spoof.AimAssist.Shake.Enabled and FrameSkip == false then
                local Mag = math.ceil((EndPosition - Client.Character.HumanoidRootPart.Position).Magnitude)
                EndPosition = EndPosition + (Vector3.new(
                    math.random(-Mag * Spoof.AimAssist.Shake.Shake_X, Mag * Spoof.AimAssist.Shake.Shake_X), 
                    math.random(-Mag * Spoof.AimAssist.Shake.Shake_Y, Mag * Spoof.AimAssist.Shake.Shake_Y), 
                    math.random(-Mag * Spoof.AimAssist.Shake.Shake_Z, Mag * Spoof.AimAssist.Shake.Shake_Z)) / 1000
                )
            end
            if Spoof.AimAssist.Method == ("Mouse") then
                local Vec2Pos = Camera:WorldToScreenPoint(EndPosition)
                local InCrementX = (Vec2Pos.X - Spoof.Silent.Fov.Offset.X) * (Spoof.AimAssist.UseSmoothness and Spoof.AimAssist.Smoothness_X or 1)
                local InCrementY = (Vec2Pos.Y - Spoof.Silent.Fov.Offset.Y) * (Spoof.AimAssist.UseSmoothness and Spoof.AimAssist.Smoothness_Y or 1)
                if FrameSkip then
                    FrameSkip = false
                    InCrementX = ((Vec2Pos.X - Spoof.Silent.Fov.Offset.X) - Mouse.X) * Spoof.AimAssist.FrameSkip.Power
                    InCrementY = ((Vec2Pos.Y - Spoof.Silent.Fov.Offset.Y) - Mouse.Y) * Spoof.AimAssist.FrameSkip.Power
                end
                mousemoverel(InCrementX, InCrementY)
            elseif Spoof.AimAssist.Method == ("Camera") then
                local Vec3Pos = CFrame.new(Camera.CFrame.p, EndPosition)
                if FrameSkip then
                    FrameSkip = false
                    Camera.CFrame = Camera.CFrame:Lerp(Vec3Pos, Spoof.AimAssist.FrameSkip.Power, Spoof.AimAssist.Advanced.EasingStyle, Spoof.AimAssist.Advanced.EasingDirection)
                    return
                end
                Camera.CFrame = Camera.CFrame:Lerp(Vec3Pos, (Spoof.AimAssist.UseSmoothness and Spoof.AimAssist.Smoothness_X or 1), Spoof.AimAssist.Advanced.EasingStyle, Spoof.AimAssist.Advanced.EasingDirection)
            end
        end
    end
end

-- // Silent Features That Needs To Be Looping
Script.Functions.SilentMisc = function()
    if Spoof.Silent.PingPrediction.Enabled and Spoof.Silent.PredictMovement and Spoof.Silent.GunSettings.Methods.Prediction == false and game:GetService("Stats") and game:GetService("Stats"):FindFirstChild("Network") and game:GetService("Stats").Network:FindFirstChild("ServerStatsItem") and game:GetService("Stats").Network.ServerStatsItem:FindFirstChild("Data Ping") then
        local Ping = math.floor(game:GetService("Stats").Network.ServerStatsItem["Data Ping"]:GetValue())
        if Spoof.Silent.PingPrediction.AutoMatic == false then
            if Ping > 200 then
                Spoof.Silent.Prediction = Spoof.Silent.PingPrediction.P200_Inf
            elseif Ping > 190 then
                Spoof.Silent.Prediction = Spoof.Silent.PingPrediction.P190_200
            elseif Ping > 180 then
                Spoof.Silent.Prediction = Spoof.Silent.PingPrediction.P180_190
            elseif Ping > 170 then
                Spoof.Silent.Prediction = Spoof.Silent.PingPrediction.P170_180
            elseif Ping > 160 then
                Spoof.Silent.Prediction = Spoof.Silent.PingPrediction.P160_170
            elseif Ping > 150 then
                Spoof.Silent.Prediction = Spoof.Silent.PingPrediction.P150_160
            elseif Ping > 140 then
                Spoof.Silent.Prediction = Spoof.Silent.PingPrediction.P140_150
            elseif Ping > 130 then
                Spoof.Silent.Prediction = Spoof.Silent.PingPrediction.P130_140
            elseif Ping > 120 then
                Spoof.Silent.Prediction = Spoof.Silent.PingPrediction.P120_130
            elseif Ping > 110 then
                Spoof.Silent.Prediction = Spoof.Silent.PingPrediction.P110_120
            elseif Ping > 100 then
                Spoof.Silent.Prediction = Spoof.Silent.PingPrediction.P100_110
            elseif Ping > 90 then
                Spoof.Silent.Prediction = Spoof.Silent.PingPrediction.P90_100
            elseif Ping > 80 then
                Spoof.Silent.Prediction = Spoof.Silent.PingPrediction.P80_90
            elseif Ping > 70 then
                Spoof.Silent.Prediction = Spoof.Silent.PingPrediction.P70_80
            elseif Ping > 60 then
                Spoof.Silent.Prediction = Spoof.Silent.PingPrediction.P60_70
            elseif Ping > 50 then
                Spoof.Silent.Prediction = Spoof.Silent.PingPrediction.P50_60
            elseif Ping > 40 then
                Spoof.Silent.Prediction = Spoof.Silent.PingPrediction.P40_50
            elseif Ping > 30 then
                Spoof.Silent.Prediction = Spoof.Silent.PingPrediction.P30_40
            elseif Ping > 20 then
                Spoof.Silent.Prediction = Spoof.Silent.PingPrediction.P20_30
            elseif Ping > 10 then
                Spoof.Silent.Prediction = Spoof.Silent.PingPrediction.P10_20
            end
        end
    end
end

-- // Gets Silent Target And Velocity
Script.Functions.GetSilentTarget = function()
    local Target = Script.Functions.GetClosestPlayer(not Spoof.Silent.ForceLock)

    if Spoof.Silent.AntiAimViewer == false and Script.Functions.Alive(Target) and Script.Functions.SilentCheck(Target) then 
        SilentTarget = Target
        local GetPart = Script.Functions.GetClosestPartMethod(Target)
        if GetPart ~= nil then
            Spoof.Silent.Part = tostring(GetPart)
            Script.SavedValue.SilentPart = tostring(GetPart)
            if Spoof.Silent.ClosestPoint then
                ClosestPointCF = Script.Functions.GetClosestPointOnPart(GetPart)
            end
        else
            SilentTarget = nil
        end
    else
        SilentTarget = Target
    end
end

-- // Desync Main Function. Velocity Change
Script.Functions.Desync = function()
    if Desync and Script.Functions.Alive(Client) and Client.Character.Humanoid.health > Spoof.Desync.HealthDeActivation then
        if Spoof.Desync.Method == ("Freeze_Pos") and sethiddenproperty then
            FreezePos = not FreezePos
            sethiddenproperty(Client.Character.HumanoidRootPart, "NetworkIsSleeping", FreezePos)
        elseif Spoof.Desync.Method == ("Slow_Data") and setfflag then
            setfflag("S2PhysicsSenderRate", 3)
        else
            local SaveVelocity = Client.Character.HumanoidRootPart.AssemblyLinearVelocity
            local SaveRotVelocity = Client.Character.HumanoidRootPart.AssemblyAngularVelocity
            if Spoof.Desync.Method == ("Vel_StandBy") then
                Client.Character.HumanoidRootPart.Velocity = Vector3.new(1,1,1) * (2^16)
                Client.Character.HumanoidRootPart.RotVelocity = Vector3.new(1,1,1) * (2^16)
            elseif Spoof.Desync.Method == ("Vel_Multi") then
                Client.Character.HumanoidRootPart.Velocity = Client.Character.HumanoidRootPart.Velocity * Spoof.Desync.Power
            elseif Spoof.Desync.Method == ("Custom_Vel") then
                Client.Character.HumanoidRootPart.Velocity = Vector3.new(Spoof.Desync.Custom.Vel_X, Spoof.Desync.Custom.Vel_Y, Spoof.Desync.Custom.Vel_Z)
            elseif Spoof.Desync.Method == ("Vel_Under") then
                Client.Character.HumanoidRootPart.Velocity = Vector3.new(0, -Spoof.Desync.Power, 0)
            elseif Spoof.Desync.Method == ("Vel_Over") then
                Client.Character.HumanoidRootPart.Velocity = Vector3.new(0, Spoof.Desync.Power, 0)
            elseif Spoof.Desync.Method == ("Vel_Zero") then
                Client.Character.HumanoidRootPart.Velocity = Vector3.zero
            end
            
            if Spoof.Desync.Visualize.Enabled then
                local GetMag = (Camera.CoordinateFrame.p - (Client.Character.HumanoidRootPart.Position + (Client.Character.HumanoidRootPart.Velocity * 0.13))).Magnitude
                local GetPos, OnScreen = Camera:WorldToScreenPoint(Client.Character.HumanoidRootPart.Position + (Client.Character.HumanoidRootPart.Velocity * 0.13))
                if OnScreen then
                    Script.Drawing.DesyncCircle.Visible = true
                    Script.Drawing.DesyncCircle.Color = Spoof.Desync.Visualize.Color
                    Script.Drawing.DesyncCircle.Radius = (Spoof.Desync.Visualize.Radius * 10) / GetMag
                    Script.Drawing.DesyncCircle.Position = Vector2.new(GetPos.X, GetPos.Y)
                else
                    Script.Drawing.DesyncCircle.Visible = false
                end
            else
                Script.Drawing.DesyncCircle.Visible = false
            end
            
            RS.RenderStepped:Wait()
            
            Client.Character.HumanoidRootPart.AssemblyLinearVelocity = SaveVelocity
            Client.Character.HumanoidRootPart.AssemblyAngularVelocity = SaveRotVelocity
        end
    else
        if Spoof.Desync.Visualize.Enabled then
            Script.Drawing.DesyncCircle.Visible = false
        end
    end
end

-- // Cheater Detection Function. Not Giving Away

-- // Update Properties Of Circle
Script.Functions.UpdateFOV = function()
    local GetScreenPos = Script.Functions.GetFovPosition()
    Script.Drawing.AimAssistCircle.Visible = Spoof.AimAssist.Fov.Visible
    Script.Drawing.AimAssistCircle.Filled = Spoof.AimAssist.Fov.Filled
    Script.Drawing.AimAssistCircle.Color = Spoof.AimAssist.Fov.Color
    Script.Drawing.AimAssistCircle.Transparency = Spoof.AimAssist.Fov.Transparency
    if Spoof.Silent.Fov.Method == ("Screen") then
        Script.Drawing.AimAssistCircle.Position = Vector2.new(GetScreenPos.X, GetScreenPos.Y) - Spoof.Silent.Fov.Offset
    else
        Script.Drawing.AimAssistCircle.Position = Vector2.new(GetScreenPos.X, GetScreenPos.Y + GuiS:GetGuiInset().Y) - Spoof.Silent.Fov.Offset
    end

	Script.Drawing.AimAssistCircle.Radius = Spoof.AimAssist.Fov.Radius * 3
    
    Script.Drawing.SilentCircle.Visible = Spoof.Silent.Fov.Visible
    Script.Drawing.SilentCircle.Color = Spoof.Silent.Fov.Color
    Script.Drawing.SilentCircle.Filled = Spoof.Silent.Fov.Filled
    Script.Drawing.SilentCircle.Transparency = Spoof.Silent.Fov.Transparency
    if Spoof.Silent.Fov.StickyFov and Script.Functions.Alive(SilentTarget) and SilentTarget.Character:FindFirstChild(Spoof.Silent.Part) then
        local PartPos, OnScreen = Camera:WorldToViewportPoint(SilentTarget.Character[Spoof.Silent.Part].Position)
        if OnScreen then
            local Magnitude = ((Vector2.new(PartPos.X, PartPos.Y) - Vector2.new(GetScreenPos.X, GetScreenPos.Y + GuiS:GetGuiInset().Y)) - Spoof.Silent.Fov.Offset).Magnitude

            if (Spoof.Silent.ForceLock == false and Script.Drawing.SilentCircle.Radius + 4 > Magnitude) or Spoof.Silent.ForceLock == true then
                Script.Drawing.SilentCircle.Position = Vector2.new(PartPos.X, PartPos.Y) - Spoof.Silent.Fov.Offset
            else
                if Spoof.Silent.Fov.Method == ("Screen") then
                    Script.Drawing.SilentCircle.Position = Vector2.new(GetScreenPos.X, GetScreenPos.Y) - Spoof.Silent.Fov.Offset
                else
                    Script.Drawing.SilentCircle.Position = Vector2.new(GetScreenPos.X, GetScreenPos.Y + GuiS:GetGuiInset().Y) - Spoof.Silent.Fov.Offset
                end
            end
        else
            if Spoof.Silent.Fov.Method == ("Screen") then
                Script.Drawing.SilentCircle.Position = Vector2.new(GetScreenPos.X, GetScreenPos.Y) - Spoof.Silent.Fov.Offset
            else
                Script.Drawing.SilentCircle.Position = Vector2.new(GetScreenPos.X, GetScreenPos.Y + GuiS:GetGuiInset().Y) - Spoof.Silent.Fov.Offset
            end
        end
    else
        if Spoof.Silent.Fov.Method == ("Screen") then
            Script.Drawing.SilentCircle.Position = Vector2.new(GetScreenPos.X, GetScreenPos.Y) - Spoof.Silent.Fov.Offset
        else
            Script.Drawing.SilentCircle.Position = Vector2.new(GetScreenPos.X, GetScreenPos.Y + GuiS:GetGuiInset().Y) - Spoof.Silent.Fov.Offset
        end
    end
	Script.Drawing.SilentCircle.Radius = SilentFovRadius.Value * 3
end

-- // Updates Esp Posistions
Script.Functions.UpdateEsp = function()
    for i, v in pairs(Script.EspPlayers) do
        if Spoof.Esp.Enabled and i.Character and i.Character:FindFirstChild("Humanoid") and i.Character:FindFirstChild("HumanoidRootPart") and i.Character:FindFirstChild("Head") then
            local Hum = i.Character.Humanoid
            local Hrp = i.Character.HumanoidRootPart
            
            local Vector, OnScreen = Camera:WorldToViewportPoint(i.Character.HumanoidRootPart.Position)
            local Size = (Camera:WorldToViewportPoint(Hrp.Position - Vector3.new(0, 3, 0)).Y - Camera:WorldToViewportPoint(Hrp.Position + Vector3.new(0, 2.6, 0)).Y) / 2
            local BoxSize = Vector2.new(math.floor(Size * 1.5), math.floor(Size * 1.9))
            local BoxPos = Vector2.new(math.floor(Vector.X - Size * 1.5 / 2), math.floor(Vector.Y - Size * 1.6 / 2))
            local BottomOffset = BoxSize.Y + BoxPos.Y + 1
            
            if OnScreen then
                if Spoof.Esp.Name.Enabled then
                    v.Name.Position = Vector2.new(BoxSize.X / 2 + BoxPos.X, BoxPos.Y - 16)
                    v.Name.Outline = Spoof.Esp.Name.OutLine
                    v.Name.Text = Hum.DisplayName
                    v.Name.Color = Spoof.Esp.Name.Color
                    v.Name.OutlineColor = Color3.fromRGB(0, 0, 0)
                    v.Name.Font = 0
                    v.Name.Size = Spoof.Esp.TextSize

                    v.Name.Visible = true
                else
                    v.Name.Visible = false
                end

                if Spoof.Esp.Distance.Enabled and Client.Character and Client.Character:FindFirstChild("HumanoidRootPart") then
                    v.Distance.Position = Vector2.new(BoxSize.X / 2 + BoxPos.X, BottomOffset)
                    v.Distance.Outline = Spoof.Esp.Distance.OutLine
                    v.Distance.Text = "[" .. math.floor((Hrp.Position - Client.Character.HumanoidRootPart.Position).Magnitude) .. "m]"
                    v.Distance.Color = Spoof.Esp.Distance.Color
                    v.Distance.OutlineColor = Color3.fromRGB(0, 0, 0)

                    v.Distance.Font = 0
                    v.Distance.Size = Spoof.Esp.TextSize

                    v.Distance.Visible = true
                else
                    v.Distance.Visible = false
                end

                if Spoof.Esp.Tool.Enabled then
                    if Spoof.Esp.Distance.Enabled then
                        v.Tool.Position = Vector2.new(BoxSize.X / 2 + BoxPos.X, BottomOffset + 13)
                    else
                        v.Tool.Position = Vector2.new(BoxSize.X / 2 + BoxPos.X, BottomOffset)
                    end
                    v.Tool.Outline = Spoof.Esp.Tool.OutLine
                    if i.Character:FindFirstChildWhichIsA("Tool") then
                        if i.Character:FindFirstChild("GunScript", true) ~= nil or i.Character:FindFirstChild("FlameThrowerScript", true) ~= nil or i.Character:FindFirstChild("RPGScript", true) ~= nil then
                            v.Tool.Text = i.Character:FindFirstChildWhichIsA("Tool").Name
                        else
                            v.Tool.Text = "[" .. i.Character:FindFirstChildWhichIsA("Tool").Name .. "]"
                        end
                    else
                        v.Tool.Text = "[None]"
                    end
                    v.Tool.Color = Spoof.Esp.Tool.Color
                    v.Tool.OutlineColor = Color3.fromRGB(0, 0, 0)
                    
                    v.Tool.Font = 0
                    v.Tool.Size = Spoof.Esp.TextSize

                    v.Tool.Visible = true
                else
                    v.Tool.Visible = false
                end

                if Spoof.Esp.Box.Enabled then
                    v.BoxOutline.Size = BoxSize
                    v.BoxOutline.Position = BoxPos
                    v.BoxOutline.Visible = Spoof.Esp.Box.OutLine
                    v.BoxOutline.Color = Color3.fromRGB(0, 0, 0)
                    
                    v.Box.Size = BoxSize
                    v.Box.Position = BoxPos
                    if Spoof.Esp.TargetColor.Enabled and SilentTarget ~= nil and i == SilentTarget then
                        v.Box.Color = Spoof.Esp.TargetColor.Color
                    elseif Spoof.Esp.CrewColor.Enabled and Script.Functions.FindCrew(i) and i.DataFolder.Information:FindFirstChild("Crew").Value == Client.DataFolder.Information:FindFirstChild("Crew").Value then
                        v.Box.Color = Spoof.Esp.CrewColor.Color
                    else
                        v.Box.Color = Spoof.Esp.Box.Color
                    end
                    v.Box.Visible = true
                else
                    v.BoxOutline.Visible = false
                    v.Box.Visible = false
                end

                if Spoof.Esp.HealthBar.Enabled then
                    if Spoof.Esp.HealthBar.HealthColor then
                        local Health = i.Character.Humanoid.Health / i.Character.Humanoid.MaxHealth
                        v.HealthBar.Color = Color3.fromHSV(Health * 0.3, 1, 1) 
                    else
                        v.HealthBar.Color = Spoof.Esp.HealthBar.Color
                    end

                    v.HealthBar.From = Vector2.new((BoxPos.X - 5), BoxPos.Y + BoxSize.Y)
                    v.HealthBar.To = Vector2.new(v.HealthBar.From.X, v.HealthBar.From.Y - (Hum.Health / Hum.MaxHealth) * BoxSize.Y)
                    v.HealthBar.Visible = true

                    v.HealthBarOutline.From = Vector2.new(v.HealthBar.From.X, BoxPos.Y + BoxSize.Y + 1)
                    v.HealthBarOutline.To = Vector2.new(v.HealthBar.From.X, (v.HealthBar.From.Y - 1 * BoxSize.Y) - 1)
                    v.HealthBarOutline.Color = Color3.fromRGB(0, 0, 0)
                    v.HealthBarOutline.Visible = Spoof.Esp.HealthBar.OutLine
                else
                    v.HealthBarOutline.Visible = false
                    v.HealthBar.Visible = false
                end

                if Spoof.Esp.HealthText.Enabled then
                    local Offset = 22
                    if Spoof.Esp.ArmorBar.Enabled == false then
                        Offset = Offset - 7
                    end
                    if Spoof.Esp.HealthBar.Enabled == false then
                        Offset = Offset - 7
                    end

                    if Spoof.Esp.HealthText.HealthColor then
                        local Health = i.Character.Humanoid.Health / i.Character.Humanoid.MaxHealth
                        v.HealthText.Color = Color3.fromHSV(Health * 0.3, 1, 1) 
                    else
                        v.HealthText.Color = Spoof.Esp.HealthText.Color
                    end
                    
                    v.HealthText.Text = tostring(math.floor((Hum.Health / Hum.MaxHealth) * 100 + 0.5))
                    v.HealthText.Position = Vector2.new((BoxPos.X - Offset), (BoxPos.Y + BoxSize.Y - 1 * BoxSize.Y) - 1)
                    v.HealthText.OutlineColor = Color3.fromRGB(0, 0, 0)
                    v.HealthText.Outline = Spoof.Esp.HealthText.OutLine

                    v.HealthText.Font = 0
                    v.HealthText.Size = Spoof.Esp.TextSize

                    v.HealthText.Visible = true
                else
                    v.HealthText.Visible = false
                end

                if Spoof.Esp.Flags.Enabled then
                    local Offset = 10
                    if Spoof.Esp.ArmorBar.Enabled == false then
                        Offset = Offset - 7
                    end
                    if Spoof.Esp.HealthBar.Enabled == false then
                        Offset = Offset - 7
                    end
                    if i.Character.HumanoidRootPart.Velocity.Magnitude > 120 and Spoof.Esp.Flags.DesyncState then
                        v.Flag.Text = "Desyncing"
                    elseif i.Character.HumanoidRootPart.Velocity.Y > 2 and Spoof.Esp.Flags.WalkingState then
                        v.Flag.Text = "Jumping"
                    elseif i.Character.HumanoidRootPart.Velocity.Y < -2 and Spoof.Esp.Flags.WalkingState then
                        v.Flag.Text = "Falling"
                    elseif i.Character.HumanoidRootPart.Velocity.Magnitude > 2 and Spoof.Esp.Flags.WalkingState then
                        v.Flag.Text = "Walking"
                    elseif i.Character.HumanoidRootPart.Velocity.Magnitude < 1 and Spoof.Esp.Flags.WalkingState then
                        v.Flag.Text = "Standing"
                    end
                    v.Flag.Position = Vector2.new((BoxPos.X - Offset) - (string.len(v.Flag.Text) * 3), (BoxPos.Y + BoxSize.Y - 1 * BoxSize.Y) + 22)
                    v.Flag.Color = Spoof.Esp.Flags.Color
                    v.Flag.OutlineColor = Color3.fromRGB(0, 0, 0)
                    v.Flag.Outline = Spoof.Esp.Flags.OutLine

                    v.Flag.Font = 0
                    v.Flag.Size = Spoof.Esp.TextSize

                    v.Flag.Visible = true
                else
                    v.Flag.Visible = false
                end

                if Spoof.Esp.Tracer.Enabled then
                    if Spoof.Esp.Tracer.Method == ("Screen") then
                        v.Tracer.From = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y)
                    else
                        v.Tracer.From = Vector2.new(Mouse.X, Mouse.Y + GuiS:GetGuiInset().Y)
                    end
                    v.Tracer.To = Vector2.new(Vector.X, Vector.Y)
                    v.Tracer.Thickness = Spoof.Esp.Tracer.Thickness
                    v.Tracer.Color = Spoof.Esp.Tracer.Color
                    v.Tracer.Visible = true
                else
                    v.Tracer.Visible = false
                end

                if i.Character:FindFirstChild("BodyEffects") and i.Character:FindFirstChild("BodyEffects"):FindFirstChild("Armor") then
                    if Spoof.Esp.ArmorBar.Enabled then
                        if Spoof.Esp.HealthBar.Enabled then
                            v.ArmorBar.From = Vector2.new((BoxPos.X - 9), BoxPos.Y + BoxSize.Y)
                        else
                            v.ArmorBar.From = Vector2.new((BoxPos.X - 5), BoxPos.Y + BoxSize.Y)
                        end
                        v.ArmorBar.To = Vector2.new(v.ArmorBar.From.X, v.ArmorBar.From.Y - (i.Character.BodyEffects.Armor.Value / 200) * BoxSize.Y)
                        v.ArmorBar.Color = Spoof.Esp.ArmorBar.Color
                        v.ArmorBar.Visible = true

                        v.ArmorBarOutline.From = Vector2.new(v.ArmorBar.From.X, BoxPos.Y + BoxSize.Y + 1)
                        v.ArmorBarOutline.To = Vector2.new(v.ArmorBar.From.X, (v.ArmorBar.From.Y - 1 * BoxSize.Y) - 1)
                        v.ArmorBarOutline.Color = Color3.fromRGB(0, 0, 0)
                        v.ArmorBarOutline.Visible = Spoof.Esp.ArmorBar.OutLine
                    else
                        v.ArmorBarOutline.Visible = false
                        v.ArmorBar.Visible = false
                    end
                    if Spoof.Esp.ArmorText.Enabled then
                        local Offset = 22
                        if Spoof.Esp.ArmorBar.Enabled == false then
                            Offset = Offset - 7
                        end
                        if Spoof.Esp.HealthBar.Enabled == false then
                            Offset = Offset - 7
                        end
                        v.ArmorText.Text = tostring(math.floor((i.Character.BodyEffects.Armor.Value / 2) + 0.5))
                        if Spoof.Esp.HealthText.Enabled then
                            v.ArmorText.Position = Vector2.new((BoxPos.X - Offset), (BoxPos.Y + BoxSize.Y - 1 * BoxSize.Y) + 11)
                        else
                            v.ArmorText.Position = Vector2.new((BoxPos.X - Offset), (BoxPos.Y + BoxSize.Y - 1 * BoxSize.Y) - 1)
                        end
                        v.ArmorText.Color = Spoof.Esp.ArmorText.Color
                        v.ArmorText.OutlineColor = Color3.fromRGB(0, 0, 0)
                        v.ArmorText.Outline = Spoof.Esp.ArmorText.OutLine

                        v.ArmorText.Font = 0
                        v.ArmorText.Size = Spoof.Esp.TextSize

                        v.ArmorText.Visible = true
                    else
                        v.ArmorText.Visible = false
                    end
                else
                    v.ArmorBarOutline.Visible = false
                    v.ArmorBar.Visible = false
                    v.ArmorText.Visible = false
                end 
            else
                v.Name.Visible = false
                v.BoxOutline.Visible = false
                v.Box.Visible = false
                v.HealthBarOutline.Visible = false
                v.HealthBar.Visible = false
                v.HealthText.Visible = false
                v.ArmorBarOutline.Visible = false
                v.ArmorBar.Visible = false
                v.ArmorText.Visible = false
                v.Distance.Visible = false
                v.Tool.Visible = false
                v.Flag.Visible = false
                v.Tracer.Visible = false
            end
        else
            v.Name.Visible = false
            v.BoxOutline.Visible = false
            v.Box.Visible = false
            v.HealthBarOutline.Visible = false
            v.HealthBar.Visible = false
            v.HealthText.Visible = false
            v.ArmorBarOutline.Visible = false
            v.ArmorBar.Visible = false
            v.ArmorText.Visible = false
            v.Distance.Visible = false
            v.Tool.Visible = false
            v.Flag.Visible = false
            v.Tracer.Visible = false
        end
    end
end

-- // Recreates An Table
Script.Functions.GetTable = function(Table)
    if type(Table) == ("table") then
        local Writer = {}
        Writer.__index = Writer
    
        Writer.New = function()
            local self = setmetatable({}, Writer)
            self.Indent = 0
            self.Text = ""
            return self
        end
    
        Writer.WriteIndentation = function(self)
            for i = 1, self.Indent do
                self.Text = self.Text .. "\t"
            end
        end
    
        Writer.Write = function(self, Text)
            self.Text = self.Text .. Text
        end
    
        Writer.WriteLine = function(self, Text)
            self.Text = self.Text .. Text .. "\n"
        end
    
        Writer.WriteIndent = function(self, Text)
            self:WriteIndentation()
            self:Write(Text)
        end
    
        Writer.IncIndent = function(self)
            self.Indent = self.Indent + 1
        end
    
        Writer.Unindent = function(self)
            self.Indent = self.Indent - 1
        end
    
        Writer.ToString = function(self)
            return self.Text
        end
    
        Writer.Clear = function(self)
            self.Text = ""
            self.Indent = 0
        end
    
        local TableDump = {}
        TableDump.__index = TableDump
    
        TableDump.New = function(Table)
            local self = setmetatable({}, TableDump)
            self.Writer = Writer.New()
            self.Ot = Table
            self.Memory = {}
            self.VisitedTables = {}
            return self
        end
    
        TableDump.CacheGlobalMemory = function(self)
            local CurrentTrack = {"_G"}
            local Functions = {}
    
            Functions.InternalCount = function(Table)
                local Current = 0
                for _, __ in pairs(Table) do
                    Current = Current + 1
                end
                return Current
            end
    
            Functions.CreateNamespace = function()
                local NameSpace = ""
                for Index, Value in pairs(CurrentTrack) do
                    if Value ~= ("_G") and Value ~= ("package") then
                        NameSpace = NameSpace .. Value .. "."
                    end
                end
                return NameSpace
            end
    
            Functions.InternalCache = function(Table)
                local Len = Functions.InternalCount(Table)
                local Current = 0
                for Index, value in pairs(Table) do
                    Current = Current + 1
                    if type(value) == ("function") or type(value) == ("table") then
                        if type(value) == ("table") and self.VisitedTables[value] == nil then
                            self.VisitedTables[value] = Index
                            CurrentTrack[#CurrentTrack + 1] = Index
                            Functions.InternalCache(value)
                        end
                        self.Memory[value] = Functions.CreateNamespace() .. Index
                    end
                    if Current == Len then
                        table.remove(CurrentTrack, #CurrentTrack)
                    end
                end
            end
    
            Functions.InternalCache(_G)
        end
    
        TableDump.Resolve = function(self)
            self:CacheGlobalMemory()
            local Functions = {}

            Functions.InternalResolveSpecial = function(Value)
                if Value == _G then
                    return "_G"
                end
                if self.Memory[Value] then
                    return self.Memory[Value]
                end
                if type(Value) == ("table") then
                    if self.VisitedTables[Value] ~= nil then
                        if self.VisitedTables[Value] == true then
                            return "{...}"
                        end
                        return self.VisitedTables
                    end
                    Functions.InternalResolve(Value)
                    return ""
                elseif type(Value) == ("function") then
                    return '"Function Couldnt Be Added: ' .. tostring(Value) .. '"'
                end
                return tostring(Value)
            end
    
            Functions.InternalResolveValue = function(Value)
                if type(Value) == ("function") or type(Value) == ("table") then
                    return Functions.InternalResolveSpecial(Value)
                elseif type(Value) == ("string") then
                    return '"' .. tostring(Value) .. '"'
                elseif type(Value) == ("number") and Value == math.huge then
                    return "math.huge"
                elseif type(Value) == ("number") and Value == math.pi then
                    return "math.pi"
                elseif typeof(Value) == ("Color3") then
                    return "Color3.new(" .. tostring(Value) .. ")"
                elseif typeof(Value) == ("Vector2") then
                    return "Vector2.new(" .. tostring(Value) .. ")"
                elseif typeof(Value) == ("Vector3") then
                    return "Vector3.new(" .. tostring(Value) .. ")"
                else
                    return tostring(Value)
                end
            end
    
            Functions.InternalCount = function(Table)
                local Current = 0
                for _, __ in pairs(Table) do
                    Current = Current + 1
                end
                return Current
            end
    
            Functions.InternalResolve = function(Table, Index)
                local Len = Functions.InternalCount(Table)
                local Current = 0

                if Len ~= 0 then
                    self.Writer:WriteLine("{")
                else
                    self.Writer:Write("{")
                end

                self.Writer:IncIndent()
                self.VisitedTables[Table] = true

                if Index then
                    self.VisitedTables[Table] = Index
                end

                for Index, value in pairs(Table) do
                    Current = Current + 1
                    if type(Index) == ("string") then
                        if string.find(Index, " ") then
                            self.Writer:WriteIndent('["' .. Index .. '"] = ')
                        else
                            self.Writer:WriteIndent(Index .. " = ")
                        end

                        self.Writer:Write(Functions.InternalResolveValue(value))
                    elseif type(Index) == ("number") then
                        self.Writer:WriteIndent("[" .. tostring(Index) .. "] = ")
                        self.Writer:Write(Functions.InternalResolveValue(value))
                    elseif type(Index) == ("table") then
                        self.Writer:WriteIndent("[")
                        Functions.InternalResolve(Index)
                        self.Writer:Write("] = ")
                        self.Writer:Write(Functions.InternalResolveValue(value))
                    elseif type(Index) == ("function") then
                        self.Writer:WriteIndent(Functions.InternalResolveValue(Index) .. " = ")
                        self.Writer:Write(Functions.InternalResolveValue(value))
                    else
                        self.Writer:WriteIndent(Functions.InternalResolveValue(Index) .. " = ")
                        self.Writer:Write(Functions.InternalResolveValue(value))
                    end
                    if Current == Len then
                        self.Writer:WriteLine("")
                    else
                        self.Writer:WriteLine(",")
                    end
                end

                self.Writer:Unindent()
                if Len ~= 0 then
                    self.Writer:WriteIndent("}")
                else
                    self.Writer:Write("}")
                end
            end
            Functions.InternalResolve(self.Ot)
        end
    
        TableDump.ToString = function(self)
            self:Resolve()
            return self.Writer:ToString()
        end
    
        return "return " .. TableDump.New(Table):ToString()
    else
        return "Error: Table Not Found"
    end
end

-- // Chat Change Check
Client.Chatted:Connect(function(Msg)
    if Msg == Spoof.ChatCommands.CrashMode then
        if Spoof.ChatCommands.CrashMethod == ("Freeze") then
            while true do end
        elseif Spoof.ChatCommands.CrashMethod == ("Shutdown") then
            game:Shutdown()
        end
    elseif Msg == Spoof.ChatCommands.RejoinServer then
        game:GetService("TeleportService"):TeleportToPlaceInstance(game.PlaceId, game.JobId, Client)
    elseif Msg == Spoof.ChatCommands.RandomServer then
        game:GetService("TeleportService"):Teleport(game.PlaceId, Client) 
    end
    local Splitted = string.split(Msg, " ")
    if Splitted[1] and Splitted[2] and Spoof.ChatCommands.Enabled then
        if Splitted[1] == Spoof.ChatCommands.LoadConfig then
            if isfolder("Spoof/" .. game.PlaceId) and isfolder("Spoof/" .. game.PlaceId .. "/Configs") and isfile("Spoof/" .. game.PlaceId .. "/Configs/" .. Splitted[2] .. ".lua") then
                local Table = loadfile("Spoof/" .. game.PlaceId .. "/Configs/" .. Splitted[2] .. ".lua")()
                Spoof = Table
                Script.Functions.CreateNotification("SuccesFully Loaded File (Name: " .. Splitted[2] .. ")", Color3.fromRGB(206, 67, 67))
            else
                Script.Functions.CreateNotification("Error: Couldnt Find File (Name: " .. Splitted[2] .. ")", Color3.fromRGB(206, 67, 67))
            end
        elseif Splitted[1] == Spoof.ChatCommands.SaveConfig then
            if not isfolder("Spoof") then
                makefolder("Spoof")
            end
            if not isfolder("Spoof/" .. game.PlaceId) then
                makefolder("Spoof/" .. game.PlaceId)
            end
            if not isfolder("Spoof/" .. game.PlaceId .. "/Configs") then
                makefolder("Spoof/" .. game.PlaceId .. "/Configs")
            end
            if not isfile("Spoof/" .. game.PlaceId .. "/Configs/" .. Splitted[2] .. ".lua") then
                writefile("Spoof/" .. game.PlaceId .. "/Configs/" .. Splitted[2] .. ".lua", Script.Functions.GetTable(Spoof))
                Script.Functions.CreateNotification("SuccesFully Created File (Name: " .. Splitted[2] .. ")", Color3.fromRGB(206, 67, 67))
            else
                Script.Functions.CreateNotification("Error: File Already Exists (Name: " .. Splitted[2] .. ")", Color3.fromRGB(206, 67, 67))
            end
        elseif Splitted[1] == Spoof.ChatCommands.Silent_Prediction then
            Spoof.Silent.Prediction = Splitted[2]
        elseif Splitted[1] == Spoof.ChatCommands.Silent_Fov_Size then
            SilentFovRadius.Value = Splitted[2]
        elseif Splitted[1] == Spoof.ChatCommands.Silent_Fov_Show then
            if Splitted[2] == ("true") then
                Spoof.Silent.Fov.Visible = true
            else
                Spoof.Silent.Fov.Visible = false
            end
        elseif Splitted[1] == Spoof.ChatCommands.Silent_Enabled then
            if Splitted[2] == ("true") then
                Spoof.Silent.Enabled = true
            else
                Spoof.Silent.Enabled = false 
            end
        elseif Splitted[1] == Spoof.ChatCommands.Silent_HitChance then
            Spoof.Silent.HitChance = Splitted[2]
        elseif Splitted[1] == Spoof.ChatCommands.Silent_LegitMode then
            if Splitted[2] == ("true") then
                Spoof.Silent.LegitMode = true
            else
                Spoof.Silent.LegitMode = false
            end
        elseif Splitted[1] == Spoof.ChatCommands.Silent_BlatantMode then
            if Splitted[2] == ("true") then
                Spoof.Silent.BlatantMode = true
            else
                Spoof.Silent.BlatantMode = false
            end
        elseif Splitted[1] == Spoof.ChatCommands.AimAssist_Prediction then
            Spoof.AimAssist.Prediction = Splitted[2]
        elseif Splitted[1] == Spoof.ChatCommands.AimAssist_Fov_Size then
            Spoof.AimAssist.Fov.Radius = Splitted[2]
        elseif Splitted[1] == Spoof.ChatCommands.AimAssist_Fov_Show then
            if Splitted[2] == ("true") then
                Spoof.AimAssist.Fov.Visible = true
            else
                Spoof.AimAssist.Fov.Visible = false
            end
        elseif Splitted[1] == Spoof.ChatCommands.AimAssist_Enabled then
            if Splitted[2] == ("true") then
                Spoof.AimAssist.Enabled = true
            else
                Spoof.AimAssist.Enabled = false
            end
        elseif Splitted[1] == Spoof.ChatCommands.AimAssist_SmoothX then
            Spoof.AimAssist.Smoothness_X = Splitted[2]
            Script.SavedValue.AimAssistSmoothX = Spoof.AimAssist.Smoothness_X
        elseif Splitted[1] == Spoof.ChatCommands.AimAssist_SmoothY then
            Spoof.AimAssist.Smoothness_Y = Splitted[2]
            Script.SavedValue.AimAssistSmoothY = Spoof.AimAssist.Smoothness_Y
        elseif Splitted[1] == Spoof.ChatCommands.AimAssist_Shake then
            Spoof.AimAssist.Shake.Shake_X = Splitted[2]
            Spoof.AimAssist.Shake.Shake_Y = Splitted[2]
            Spoof.AimAssist.Shake.Shake_Z = Splitted[2]
            Script.SavedValue.ShakeX = Spoof.AimAssist.Shake.Shake_X
            Script.SavedValue.ShakeY = Spoof.AimAssist.Shake.Shake_Y
            Script.SavedValue.ShakeZ = Spoof.AimAssist.Shake.Shake_Z
        end
    end
end)

-- // KeyDown Mouse Check
Uis.InputBegan:connect(function(input, Gp)
    if not Gp then
        -- // Not ElseIf So You Can Use Multiple Same Keybinds
        if input.KeyCode == Enum.KeyCode[string.upper(Spoof.InventorySorter.KeyBind)] and Spoof.InventorySorter.Enabled and Script.Functions.Alive(Client) then
            local GunOrder = Spoof.InventorySorter.Slots
            local BackPack = Client.Backpack
            local CurrentTime = tick()
            local GunLoop = 10 - #GunOrder
            local TimeSinceLastKeybind = CurrentTime - keybindTime

            if TimeSinceLastKeybind >= 5 then
                keybindTime = CurrentTime
                local GunFolder = Instance.new("Folder")
                GunFolder.Name = "GunFolder"
                GunFolder.Parent = game.Workspace
                local GunFolderID = game.Workspace.GunFolder

                for _, v in pairs(BackPack:GetChildren()) do
                    if v:IsA("Tool") then
                        v.Parent = game.Workspace.GunFolder
                    end
                end

                for _, v in pairs(GunOrder) do
                    local Gun = GunFolderID:FindFirstChild(v)
                    if Gun then
                        Gun.Parent = BackPack
                        wait(0.05)
                    else
                        GunLoop = GunLoop + 1
                    end
                end

                if Spoof.InventorySorter.UseFood then
                    for _, v in pairs(GunFolderID:GetChildren()) do
                        if v:FindFirstChild("Drink") or v:FindFirstChild("Eat") then
                            v.Parent = BackPack
                            GunLoop = GunLoop -1
                        end
                    end
                end

                if GunLoop > 0 then
                    for i = 1, GunLoop do
                        local InvisTool = Instance.new("Tool")
                        InvisTool.Name = ""
                        InvisTool.ToolTip = "PlaceHolder"
                        InvisTool.GripPos = Vector3.new(0, 1, 0)
                        InvisTool.RequiresHandle = false
                        InvisTool.Parent = BackPack
                    end
                end

                for _, v in pairs(GunFolderID:GetChildren()) do
                    if v:IsA("Tool") then
                        v.Parent = BackPack
                    end
                end

                for _, v in pairs(BackPack:GetChildren()) do
                    if v.Name == "" then
                        v:Destroy()
                    end
                end

                GunFolder:Destroy()
            end
        end
        
        if Spoof.FakeSpike.Enabled and input.KeyCode == Enum.KeyCode[string.upper(Spoof.FakeSpike.KeyBind)] then
            if Spoof.FakeSpike.ToggleMode then
                FakeSpike = not FakeSpike
                if FakeSpike == true then
                    settings().Network.IncomingReplicationLag = (Spoof.FakeSpike.Power * 0.001)
                    if Spoof.Options.NotificationMode.Enabled and Spoof.Options.NotificationMode.FakeSpike then
                        Script.Functions.CreateNotification("FakeSpike: " .. tostring(FakeSpike), Color3.fromRGB(206, 67, 67))
                    end
                else
                    settings().Network.IncomingReplicationLag = 0
                    if Spoof.Options.NotificationMode.Enabled and Spoof.Options.NotificationMode.FakeSpike then
                        Script.Functions.CreateNotification("FakeSpike: " .. tostring(FakeSpike), Color3.fromRGB(206, 67, 67))
                    end
                end
            else
                settings().Network.IncomingReplicationLag = (Spoof.FakeSpike.Power * 0.001)
                if Spoof.Options.NotificationMode.Enabled and Spoof.Options.NotificationMode.FakeSpike then
                    Script.Functions.CreateNotification("FakeSpike: " .. tostring(FakeSpike), Color3.fromRGB(206, 67, 67))
                end
                task.wait(Spoof.FakeSpike.Delay)
                settings().Network.IncomingReplicationLag = 0
                if Spoof.Options.NotificationMode.Enabled and Spoof.Options.NotificationMode.FakeSpike then
                    Script.Functions.CreateNotification("FakeSpike: " .. tostring(FakeSpike), Color3.fromRGB(206, 67, 67))
                end
            end
        end

        if Spoof.F9Cleaner.Enabled and input.KeyCode == Enum.KeyCode[string.upper(Spoof.F9Cleaner.KeyBind)] then
            Script.Functions.ClearConsole()
        end

        if input.KeyCode == Enum.KeyCode[string.upper(Spoof.AimAssist.FrameSkip.KeyBind)] and Script.Functions.Alive(AimTarget) and Spoof.AimAssist.FrameSkip.Enabled then
            FrameSkip = true
        end

        if input.KeyCode == Enum.KeyCode[string.upper(Spoof.Silent.ForceKeyBind)] and Spoof.Silent.ForceLock_AimAssistTarget == false and Spoof.Silent.ForceLock then
            if ForceLock == nil then
                ForceLock = Script.Functions.GetClosestPlayer(true)
        		if Spoof.Options.NotificationMode.Enabled and Spoof.Options.NotificationMode.Misc and ForceLock ~= nil then
        		    Script.Functions.CreateNotification("Locked: " .. tostring(ForceLock), Color3.fromRGB(206, 67, 67))
        		end
            else
                if ForceLock ~= nil then
                    ForceLock = nil
            		if Spoof.Options.NotificationMode.Enabled and Spoof.Options.NotificationMode.Misc then
            		    Script.Functions.CreateNotification("Unlocked", Color3.fromRGB(206, 67, 67))
            		end
        		end
            end
        end

        if input.KeyCode == Enum.KeyCode.I and Spoof.Macro.Speed_MacroAbuse and Script.Functions.Alive(Client) then
            if Client.Character:FindFirstChild("GunScript", true) ~= nil or Client.Character:FindFirstChild("FlameThrowerScript", true) ~= nil or Client.Character:FindFirstChild("RPGScript", true) ~= nil then
                local Controller = require(Client:WaitForChild("PlayerScripts"):WaitForChild("PlayerModule")):GetCameras().activeCameraController
                Controller:SetCameraToSubjectDistance(Controller.currentSubjectDistance - 5)
            end
        end

        if input.KeyCode == Enum.KeyCode.O and Spoof.Macro.Speed_MacroAbuse and Script.Functions.Alive(Client) then
            if Client.Character:FindFirstChild("GunScript", true) ~= nil or Client.Character:FindFirstChild("FlameThrowerScript", true) ~= nil or Client.Character:FindFirstChild("RPGScript", true) ~= nil then
                local Controller = require(Client:WaitForChild("PlayerScripts"):WaitForChild("PlayerModule")):GetCameras().activeCameraController
                Controller:SetCameraToSubjectDistance(Controller.currentSubjectDistance + 5)
            end
        end

        if input.KeyCode == Enum.KeyCode[string.upper(Spoof.AimAssist.KeyBind)] and Spoof.AimAssist.Enabled then
            if AimTarget == nil then
                CurrentVelocity2 = Vector3.zero
                AimTarget = Script.Functions.GetClosestPlayer2()
                if Spoof.Options.NotificationMode.Enabled and Spoof.Options.NotificationMode.AimAssist and AimTarget ~= nil then
                    Script.Functions.CreateNotification("Locked: " .. tostring(AimTarget), Color3.fromRGB(206, 67, 67))
                end
                if AimTarget and AimTarget.Character then
                    PositionData2 = {Target = tostring(AimTarget), Position = AimTarget.Character.HumanoidRootPart.Position, Time = tick()}
                end
            else
                if AimTarget ~= nil then
                    AimTarget = nil
                    CurrentVelocity2 = Vector3.zero
                    if Spoof.Options.NotificationMode.Enabled and Spoof.Options.NotificationMode.AimAssist then
                        Script.Functions.CreateNotification("Unlocked", Color3.fromRGB(206, 67, 67))
                    end
                end
            end
        end

        if Spoof.Silent.TriggerBot and Spoof.Silent.TriggerBot_HotKey == false and input.UserInputType == Enum.UserInputType[Spoof.Silent.TriggerBotMouseKey] then
            TriggerBot = not TriggerBot
        end

        if Spoof.Silent.TriggerBot and Spoof.Silent.TriggerBot_HotKey and input.KeyCode == Enum.KeyCode[Spoof.Silent.TriggerBotKey] then
            TriggerBot = not TriggerBot
        end

        if input.KeyCode == Enum.KeyCode[string.upper(Spoof.Silent.KeyBind)] and Spoof.Silent.UseSilentKeyBind then
            Spoof.Silent.Enabled = not Spoof.Silent.Enabled
            if Spoof.Options.NotificationMode.Enabled and Spoof.Options.NotificationMode.Silent then
                Script.Functions.CreateNotification("Silent Aim: " .. tostring(Spoof.Silent.Enabled), Color3.fromRGB(206, 67, 67))
            end
            CurrentVelocity = Vector3.zero
        end

        if input.KeyCode == Enum.KeyCode[string.upper(Spoof.Macro.Lay_KeyBind)] and Spoof.Macro.Lay_Emote and game.PlaceId ~= 9825515356 then
            local Args = {
                [1] = "AnimationPack",
                [2] = "Lay"
            }
            game:GetService("ReplicatedStorage").MainEvent:FireServer(unpack(Args))
        end

        if input.KeyCode == Enum.KeyCode[string.upper(Spoof.Macro.Greet_Keybind)] and Spoof.Macro.Greet_Emote and game.PlaceId ~= 9825515356 then
            local Args = {
                [1] = "AnimationPack",
                [2] = "Greet"
            }
            game:GetService("ReplicatedStorage").MainEvent:FireServer(unpack(Args))
        end

        if input.KeyCode == Enum.KeyCode[string.upper(Spoof.Esp.EspKey)] and Spoof.Esp.UseEspKeyBind then
    		Spoof.Esp.Enabled = not Spoof.Esp.Enabled
    		if Spoof.Options.NotificationMode.Enabled and Spoof.Options.NotificationMode.Esp then
    		    Script.Functions.CreateNotification("Esp: " .. tostring(Spoof.Esp.Enabled), Color3.fromRGB(206, 67, 67))
    		end
        end

        if input.KeyCode == Enum.KeyCode[string.upper(Spoof.Desync.DesyncKey)] and Spoof.Desync.Enabled and Spoof.Desync.UseDesyncKey then
    		Desync = not Desync
    		if Spoof.Options.NotificationMode.Enabled and Spoof.Options.NotificationMode.Esp then
    		    Script.Functions.CreateNotification("Desync: " .. tostring(Desync), Color3.fromRGB(206, 67, 67))
    		end
            if Spoof.Desync.Method == ("Slow_Data") then
                wait()
                setfflag("S2PhysicsSenderRate", 15)
            end
        end

        if input.KeyCode == Enum.KeyCode[string.upper(Spoof.Macro.Noclip_KeyBind)] and Spoof.Macro.Noclip_Macro then
            NoclipMacro = not NoclipMacro
            if not NoclipMacro then return end
            repeat task.wait()
                for _, v in pairs(Client.Backpack:GetChildren()) do
                    if Script.Functions.Alive(Client) then
                        if v.Name == ("[TacticalShotgun]") then
                            v.Parent = Client.Character
                            task.wait(0.1)
                            if v then
                                v.Parent = Client.Backpack
                            end
                        elseif v.Name == ("[Shotgun]") then
                            v.Parent = Client.Character
                            task.wait(0.1)
                            if v then
                                v.Parent = Client.Backpack
                            end
                        end
                    end
                end
            until NoclipMacro == false
        end

        if input.KeyCode == Enum.KeyCode[string.upper(Spoof.Macro.Speed_KeyBind)] and Spoof.Macro.Speed_Enabled then
            Macro = not Macro
            repeat RS.Heartbeat:Wait()
            if Spoof.Macro.Speed_Method == ("FirstPerson") then
                local Controller = require(Client:WaitForChild("PlayerScripts"):WaitForChild("PlayerModule")):GetCameras().activeCameraController
                Controller:SetCameraToSubjectDistance(Controller.currentSubjectDistance - 1)
                for i = 1, math.ceil(Spoof.Macro.Speed_Delay) do
                    RS.Heartbeat:Wait()
                end
                Controller:SetCameraToSubjectDistance(Controller.currentSubjectDistance + 1)
            elseif Spoof.Macro.Speed_Method == ("Shift") then
                keypress(0xA0)
                for i = 1, math.ceil(Spoof.Macro.Speed_Delay) do
                    RS.Heartbeat:Wait()
                end
                keypress(0xA0)
                for i = 1, math.ceil(Spoof.Macro.Speed_Delay) do
                    RS.Heartbeat:Wait()
                end
                keyrelease(0xA0)
                for i = 1, math.ceil(Spoof.Macro.Speed_Delay) do
                    RS.Heartbeat:Wait()
                end
                keyrelease(0xA0)
            elseif Spoof.Macro.Speed_Method == ("ThirdPerson") then
                if Spoof.Macro.Speed_ThirdPersonV2 then
                    local Controller = require(Client:WaitForChild("PlayerScripts"):WaitForChild("PlayerModule")):GetCameras().activeCameraController
                    Controller:SetCameraToSubjectDistance(Controller.currentSubjectDistance - 8)
                    for i = 1, math.ceil(Spoof.Macro.Speed_Delay) do
                        RS.Heartbeat:Wait()
                    end
                    Controller:SetCameraToSubjectDistance(Controller.currentSubjectDistance + 5)
                else
                    keypress(0x49)
                    for i = 1, math.ceil(Spoof.Macro.Speed_Delay) do
                        RS.Heartbeat:Wait()
                    end
                    keypress(0x4F)
                    for i = 1, math.ceil(Spoof.Macro.Speed_Delay) do
                        RS.Heartbeat:Wait()
                    end
                    keyrelease(0x49)
                    for i = 1, math.ceil(Spoof.Macro.Speed_Delay) do
                        RS.Heartbeat:Wait()
                    end
                    keyrelease(0x4F)
                end
            end
            for i = 1, math.ceil(Spoof.Macro.Speed_Delay) do
                RS.Heartbeat:Wait()
            end
            until Macro == false
        end

        if input.KeyCode == Enum.KeyCode[string.upper(Spoof.PanicMode.KeyBind)] and Spoof.PanicMode.Enabled then
            PanicMode = not PanicMode
            if PanicMode then
                if Spoof.Options.NotificationMode.Enabled and Spoof.Options.NotificationMode.PanicMode then
                    Script.Functions.CreateNotification("PanicMode: " .. tostring(PanicMode), Color3.fromRGB(206, 67, 67))
                end
                if Spoof.Options.NotificationMode == true then
                    Script.PanicModeSaves.CurrentNotificationState = Spoof.Options.NotificationMode
                    Spoof.Options.NotificationMode = not Spoof.Options.NotificationMode
                end
                if Spoof.Silent.Enabled == true then
                    Script.PanicModeSaves.CurrentSilentState = Spoof.Silent.Enabled
                    Spoof.Silent.Enabled = not Spoof.Silent.Enabled
                end
                if Spoof.AimAssist.Enabled == true then
                    Script.PanicModeSaves.CurrentAimAssistState = Spoof.AimAssist.Enabled
                    Spoof.AimAssist.Enabled = not Spoof.AimAssist.Enabled
                end
                if Spoof.AimAssist.Fov.Visible == true then
                    Script.PanicModeSaves.CurrentAimAssistFov = Spoof.AimAssist.Fov.Visible
                    Spoof.AimAssist.Fov.Visible = not Spoof.AimAssist.Fov.Visible
                end
                if Spoof.Silent.Fov.Visible == true then
                    Script.PanicModeSaves.CurrentSilentFov = Spoof.Silent.Fov.Visible
                    Spoof.Silent.Fov.Visible = not Spoof.Silent.Fov.Visible
                end
            else
                if Script.PanicModeSaves.CurrentNotificationState then
                    Spoof.Options.NotificationMode = not Spoof.Options.NotificationMode
                end
                if Spoof.Options.NotificationMode.Enabled and Spoof.Options.NotificationMode.PanicMode then
                    Script.Functions.CreateNotification("PanicMode: " .. tostring(PanicMode), Color3.fromRGB(206, 67, 67))
                end
                if Script.PanicModeSaves.CurrentSilentState then
                    Spoof.Silent.Enabled = Script.PanicModeSaves.CurrentSilentState
                end
                if Script.PanicModeSaves.CurrentAimAssistState then
                    Spoof.AimAssist.Enabled = Script.PanicModeSaves.CurrentAimAssistState
                end
                if Script.PanicModeSaves.CurrentAimAssistFov then
                    Spoof.AimAssist.Fov.Visible = Script.PanicModeSaves.CurrentAimAssistFov
                end
                if Script.PanicModeSaves.CurrentSilentFov then
                    Spoof.Silent.Fov.Visible = Script.PanicModeSaves.CurrentSilentFov
                end
            end
        end

        if input.KeyCode == Enum.KeyCode[string.upper(Spoof.Macro.Rotation_KeyBind)] and Spoof.Macro.RotationMode then
            if Spoof.AimAssist.Enabled then
                Spoof.AimAssist.Enabled = false
            end
            for i = 1, math.floor(Spoof.Macro.Degrees / Spoof.Macro.RotationSpeed) do
                Camera.CoordinateFrame = Camera.CoordinateFrame * CFrame.Angles(0, math.rad(Spoof.Macro.RotationSpeed), 0)
                RS.Heartbeat:Wait()
            end
            if Spoof.AimAssist.Enabled then
                Spoof.AimAssist.Enabled = true
            end
        end
    end
end)

-- // KeyUp Mouse Check
Uis.InputEnded:connect(function(input, Gp)
    if not Gp then
        if Spoof.Silent.TriggerBot and TriggerBot and Spoof.Silent.TriggerBot_HotKey == false and Spoof.Silent.TriggerBot_HoldMode and input.UserInputType == Enum.UserInputType[Spoof.Silent.TriggerBotMouseKey] then
            TriggerBot = false
        end

        if Spoof.Silent.TriggerBot and TriggerBot and Spoof.Silent.TriggerBot_HotKey and Spoof.Silent.TriggerBot_HoldMode and input.KeyCode == Enum.KeyCode[string.upper(Spoof.Silent.TriggerBotKey)] then
            TriggerBot = false
        end

        if input.KeyCode == Enum.KeyCode[string.upper(Spoof.Esp.EspKey)] and Spoof.Esp.UseEspKeyBind and Spoof.Esp.HoldMode and Spoof.Esp.Enabled then
    		Spoof.Esp.Enabled = false
    		if Spoof.Options.NotificationMode.Enabled and Spoof.Options.NotificationMode.Esp then
    		    Script.Functions.CreateNotification("Esp: " .. tostring(Spoof.Esp.Enabled), Color3.fromRGB(206, 67, 67))
    		end
        end

        if input.KeyCode == Enum.KeyCode[string.upper(Spoof.AimAssist.KeyBind)] and Spoof.AimAssist.Enabled and Spoof.AimAssist.HoldMode then
    		AimTarget = nil
    		CurrentVelocity2 = Vector3.zero
        end

        if input.KeyCode == Enum.KeyCode[string.upper(Spoof.Desync.DesyncKey)] and Spoof.Desync.HoldMode and Spoof.Desync.UseDesyncKey and Spoof.Desync.Enabled then
    		Desync = false
    		if Spoof.Options.NotificationMode.Enabled and Spoof.Options.NotificationMode.Desync then
    		    Script.Functions.CreateNotification("Desync: " .. tostring(Desync), Color3.fromRGB(206, 67, 67))
    		end
        end

        if input.KeyCode == Enum.KeyCode[string.upper(Spoof.Macro.Speed_KeyBind)] and Spoof.Macro.Speed_Enabled and Spoof.Macro.Speed_HoldMode and Macro then
            Macro = false
        end

        if input.KeyCode == Enum.KeyCode[string.upper(Spoof.Macro.Noclip_KeyBind)] and Spoof.Macro.Noclip_Macro and Spoof.Macro.Noclip_HoldMode and NoclipMacro then
            NoclipMacro = false
        end
    end
end)

-- // Anti Aim Viewer Functions
Script.Functions.ToolActivated = function()
    if Spoof.Silent.Enabled and Spoof.Silent.AntiAimViewer and Script.Functions.Alive(SilentTarget) and Script.Functions.SilentCheck(SilentTarget) then
        local TargetCF = nil
        local TargetFalling = false

        local GetPart = Script.Functions.GetClosestPartMethod(SilentTarget)
        if GetPart == nil then return end
        Spoof.Silent.Part = tostring(GetPart)
        Script.SavedValue.SilentPart = tostring(GetPart)
        
        if Spoof.Silent.ClosestPoint then
            TargetCF = Script.Functions.GetClosestPointOnPart(GetPart)
        else
            TargetCF = GetPart.Position
        end

        if Spoof.Silent.AntiGroundShots and CurrentVelocity.Y < Spoof.Silent.AntiGroundActivation then
            TargetFalling = true
        end
        
        if TargetCF and CurrentVelocity then
            if Spoof.Silent.PredictMovement then 
                if Spoof.Silent.BlatantMode then
                    local Enabled = true
                    local Mag = (SilentTarget.Character.Humanoid.MoveDirection).Magnitude
                    local SilentVel = SilentTarget.Character.HumanoidRootPart.Velocity
                    if (SilentVel).Magnitude > 110 then
                        Enabled = false
                    elseif SilentVel.Y > 50 then
                        Enabled = false
                    elseif SilentVel.Y < -35 then
                        Enabled = false
                    elseif SilentVel.Y > 75 then
                        Enabled = false
                    elseif (SilentVel).Magnitude < 1 and Mag > 0.01 then
                        Enabled = false
                    elseif (SilentVel).Magnitude > 5 and Mag < 0.01 then
                        Enabled = false
                    end
                    if Enabled and Spoof.UniversalCheck.WallCheck_V2 and not Script.Functions.WallCheck(SilentTarget.Character.HumanoidRootPart.Position + (SilentVel * Spoof.Silent.Prediction), SilentTarget.Character) then
                        return
                    end
                    if Enabled then
                        if TargetFalling then
                            TargetCF = TargetCF + (Vector3.new(SilentVel.X, (SilentVel.Y * Spoof.Silent.AntiGroundValue), SilentVel.Z) * Spoof.Silent.Prediction)
                        else
                            TargetCF = TargetCF + (SilentVel * Spoof.Silent.Prediction)
                        end
                    else
                        if TargetFalling then
                            TargetCF = TargetCF + (Vector3.new(CurrentVelocity.X, (CurrentVelocity.Y * Spoof.Silent.AntiGroundValue), CurrentVelocity.Z) * Spoof.Silent.Prediction)
                        else
                            TargetCF = TargetCF + (CurrentVelocity * Spoof.Silent.Prediction)
                        end
                    end
                else
                    if TargetFalling then
                        TargetCF = TargetCF + (Vector3.new(CurrentVelocity.X, (CurrentVelocity.Y * Spoof.Silent.AntiGroundValue), CurrentVelocity.Z) * Spoof.Silent.Prediction)
                    else
                        TargetCF = TargetCF + (CurrentVelocity * Spoof.Silent.Prediction)
                    end
                end
            end
            if Spoof.Silent.Humanize then
                local HumanizeValue = Spoof.Silent.HumanizeValue 
                TargetCF = (TargetCF + Script.Functions.RandomVec3(HumanizeValue, 0.01))
            end
        end
        if TargetCF then
            if Spoof.Silent.LegitMode then
                local PartPos = Camera:WorldToScreenPoint(TargetCF)
                local GetScreenPos = Script.Functions.GetFovPosition()
                local Magnitude = ((Vector2.new(PartPos.X, PartPos.Y) - GetScreenPos) - Spoof.Silent.Fov.Offset).Magnitude

                if (Spoof.Silent.ForceLock == false and Script.Drawing.SilentCircle.Radius + 4 > Magnitude) or Spoof.Silent.ForceLock == true then
                    return
                end
            end

            if Spoof.Silent.Custom_AntiAimViewerPoint.Enabled == false then
                if game.PlaceId == 13873488228 or game.PlaceId == 13872892064 or game.PlaceId == 13872913451 or game.PlaceId == 13397024889 or game.PlaceId == 15186202290 or game.PlaceId == 17403265390 or game.PlaceId == 18111448661 or game.PlaceId == 18111451594 then
                    local Args = {
                        [1] = "MOUSE",
                        [2] = TargetCF
                    }
                    game:GetService("ReplicatedStorage").MAINEVENT:FireServer(unpack(Args))
                elseif game.PlaceId == 9825515356 then
                    local Args = {
                        [1] = "MousePosUpdate",
                        [2] = TargetCF + Vector3.new(25, 100, 25)
                    }
                    game:GetService("ReplicatedStorage").MainEvent:FireServer(unpack(Args))
                elseif game.PlaceId == 2788229376 then
                    local Args = {
                        [1] = "UpdateMousePosI",
                        [2] = TargetCF
                    }
                    game:GetService("ReplicatedStorage").MainEvent:FireServer(unpack(Args))
                elseif game.PlaceId == 9183932460 or game.PlaceId == 18461632007 then
                    local Args = {
                        [1] = "UpdateMousePos",
                        [2] = TargetCF
                    }
                    game:GetService("ReplicatedStorage"):FindFirstChild(".gg/untitledhood"):FireServer(unpack(Args))
                elseif game.PlaceId == 5602055394 then
                    local Args = {
                        [1] = "MousePos",
                        [2] = TargetCF,
                        [3] = "P"
                    }
                    game:GetService("ReplicatedStorage").Bullets:FireServer(unpack(Args))
                elseif game.PlaceId == 13051460029 or game.PlaceId == 11833542073 or game.PlaceId == 13051527453 or game.PlaceId == 13395952276 then
                    local Args = {
                        [1] = "UpdateMousePos",
                        [2] = {
                            ["MousePos"] = TargetCF,
                            ["Camera"] = Vector3.new(Camera.CFrame.X, Camera.CFrame.Y, Camera.CFrame.Z)
                        }
                    }
                    game:GetService("ReplicatedStorage").MainEvent:FireServer(unpack(Args))
                else
                    local Args = {
                        [1] = "UpdateMousePos",
                        [2] = TargetCF
                    }
                    game:GetService("ReplicatedStorage").MainEvent:FireServer(unpack(Args))
                end
            else
                if type(Spoof.Silent.Custom_AntiAimViewerPoint.RemoteEvent) == ("function") then
                    local Args, MainEvent = Spoof.Silent.Custom_AntiAimViewerPoint.RemoteEvent(TargetCF)
                    if type(Args) == ("table") and MainEvent:IsA("RemotEvent") then
                        MainEvent:FireServer(unpack(Args))
                    end
                end
            end
        end
    end
end

-- // Connects The AntiAimViewer To Gun
Script.Functions.GetConnections = function(Tool)
    if Tool:IsA("Tool") then
        if ToolConnection then
            ToolConnection:Disconnect()
        end
        ToolConnection = Tool.Activated:Connect(Script.Functions.ToolActivated)
    end
end

-- // Gets Character When New Character Is Added
Script.Functions.WhenCharacterAdded = function(Character)
    Character.ChildAdded:Connect(Script.Functions.GetConnections)
end

-- // Connects The LocalPlayer Character
if Client.Character then
    Script.Functions.WhenCharacterAdded(Client.Character)
end
Client.CharacterAdded:Connect(Script.Functions.WhenCharacterAdded)

-- // Memory Spoofer Functions
Script.Functions.ChangeText = function()
    pcall(function()
        coroutine.resume(coroutine.create(function()
            local PerformanceStats = game:GetService("CoreGui").RobloxGui:FindFirstChild("PerformanceStats")
            if not PerformanceStats then return end
            for _, v in pairs(PerformanceStats:GetDescendants()) do
                if v.ClassName == "TextLabel" then
                    if v.Text:match("MB") then
                        if v.Name == "ValueLabel" then
                            v.Text = Text_1 .. "" .. Text_2
                        end
                        if v.Name == "Label" then
                            if v.Text:match("Current") then
                                v.Text = "Current " .. Text_1 .. "" .. Text_2
                            end
                            if v.Text:match("Average") then
                                v.Text = "Average " .. Text_3.. "" .. Text_4
                            end
                        end
                    end
                end
            end
        end))
        local DevConsole = game:GetService("CoreGui"):FindFirstChild("DevConsoleMaster")
        if not DevConsole then return end
        for _, v in pairs(DevConsole:GetDescendants()) do
            if v.ClassName == "TextButton" then
                if v.Text:match("MB") and not v.Text:match("Value MB") then
                    v.Text = Text_5 .. " MB"
                end
            end
        end
        if DevConsole:FindFirstChild("DevConsoleWindow"):FindFirstChild("DevConsoleUI"):FindFirstChild("MainView"):FindFirstChild("ClientMemory"):FindFirstChild("Entries"):FindFirstChild("Memory"):FindFirstChild("value") then
            DevConsole.DevConsoleWindow.DevConsoleUI.MainView.ClientMemory.Entries.Memory.value.Text =  Text_5 .. "" .. Text_6
        end
        
        local Graph = DevConsole:FindFirstChild("DevConsoleWindow"):FindFirstChild("DevConsoleUI"):FindFirstChild("MainView"):FindFirstChild("ClientMemory"):FindFirstChild("Entries"):FindFirstChild("Memory"):FindFirstChild("Graph"):FindFirstChild("graph")
        local Graph2 = DevConsole:FindFirstChild("DevConsoleWindow"):FindFirstChild("DevConsoleUI"):FindFirstChild("MainView"):FindFirstChild("ClientMemory"):FindFirstChild("Entries"):FindFirstChild("Memory"):FindFirstChild("Graph")
        if Graph then
            if Graph:FindFirstChild("LatestEntryText") then
                Graph:FindFirstChild("LatestEntryText").Text = Text_1 .. Text_7
                Graph:FindFirstChild("AxisTextY0").Text = math.floor(Text_5 * 0.9) .. Text_6
            end
            local Hover_Y = Graph.HoverDetails.HoverHorizontal.Position.Y.Offset
            local TopValue = tonumber(Graph.LatestEntryText.Text)
            local BottomValue = tonumber(Graph.AxisTextY0.Text)
            local TopText_Y = Graph.LatestEntryText.Position.Y.Offset
            local BottomText_Y = Graph.AxisTextY0.Position.Y.Offset
            local LatestEntryLine_Y = Graph.LatestEntryLine.Position.Y.Offset
            local Name = DevConsole.DevConsoleWindow.DevConsoleUI.MainView.ClientMemory.Entries.Memory.Graph.name
            
            if Hover_Y < LatestEntryLine_Y then
                TopText_Y = Graph.LatestEntryText.Position.Y.Offset
                BottomText_Y = Graph.AxisTextY0.Position.Y.Offset
            elseif Graph.AxisTextY0.Position.Y.Offset < LatestEntryLine_Y then
                TopText_Y = Name.Position.Y.Offset
                BottomText_Y = Graph.LatestEntryText.Position.Y.Offset
                TopValue = tonumber(DevConsoleUI.TopBar.LiveStatsModule["MemoryUsage_MB"].Text)
                BottomValue = tonumber(Graph.LatestEntryText.Text)
            end
            
            local HoverValue = BottomValue + ((TopValue - BottomValue) * ((Hover_Y - BottomText_Y) / (TopText_Y - BottomText_Y)))
            Graph.HoverDetails.HoverTextY.Text = string.format("%.3f", HoverValue)
        end
    end)
end

-- // The Loops That Changes The Value
coroutine.resume(coroutine.create(function()
    while Spoof.MemorySpoofer.Enabled and RS.Heartbeat:Wait() do
        Script.Functions.ChangeText()
    end
end))
    
coroutine.resume(coroutine.create(function()
    while Spoof.MemorySpoofer.Enabled do
        task.wait(Spoof.MemorySpoofer.Delay)
        Text_1 = tostring(math.random(Spoof.MemorySpoofer.Lowest, Spoof.MemorySpoofer.Maximum))
        Text_2 = tostring("." .. math.random(10, 99) .. " MB")
        Text_3 = tostring(math.random(Spoof.MemorySpoofer.Lowest, Spoof.MemorySpoofer.Maximum))
        Text_4 = tostring("." .. math.random(10, 99) .. " MB")
    end
end))
    
coroutine.resume(coroutine.create(function()
    while Spoof.MemorySpoofer.Enabled do
        task.wait(5)
        Text_5 = tostring(math.random(Spoof.MemorySpoofer.Lowest, Spoof.MemorySpoofer.Maximum))
        Text_6 = tostring("."..math.random(100, 999))
        Text_7 = tostring("."..math.random(100, 999))
    end
end))

local SavedError, SavedError2, SavedError3 = nil, nil, nil
-- // Fires Every Frame Prior To The Frame Being Rendered.
coroutine.resume(coroutine.create(function()
    while true do
        local Succes, Error = pcall(function()
            if Client.Character and Client.Character:FindFirstChild("LowerTorso") and Client.Character.LowerTorso:FindFirstChild("LeftHipRigAttachment") and Client.Character.LowerTorso.LeftHipRigAttachment:FindFirstChild("OriginalPosition") then
                Client.Character.LowerTorso.LeftHipRigAttachment.OriginalPosition:Destroy()
            end
            if Spoof.Options.AntiError then 
                coroutine.wrap(pcall)(function()
                    for _, v in ipairs(getconnections(game:GetService('ScriptContext').Error)) do 
                        v:Disable();
                    end
                end)
            end
            Script.Functions.Desync()
            Script.Functions.GetSilentTarget()
            Script.Functions.UpdateFOV()
            if Spoof.Options.AutoGetUp and Script.Functions.Alive(Client) and Client.Character.Humanoid:GetState() == Enum.HumanoidStateType.FallingDown then
                Client.Character.Humanoid:ChangeState("GettingUp")
            end
            Script.Functions.MouseChanger()
            if TriggerBot and Script.Functions.Alive(SilentTarget) and SilentTarget.Character:FindFirstChild(Spoof.Silent.Part) then
                local Magnitude = Script.Functions.GetMagnitudeFromMouse(SilentTarget.Character.HumanoidRootPart)

                if (Spoof.Silent.ForceLock == false and Script.Drawing.SilentCircle.Radius + 4 > Magnitude) or Spoof.Silent.ForceLock == true then
                    if Spoof.Silent.TriggerBot_Delay == 0 then
                        mouse1click()
                    else
                        task.spawn(function()
                            task.wait(Spoof.Silent.TriggerBot_Delay / 1000)
                            mouse1click()
                        end)
                    end
                end
            end
            Script.Functions.SilentMisc()
            Script.Functions.UpdateEsp()
        end)
        if not Succes then
            if SavedError ~= Error then
                SavedError = Error
                Script.Functions.CreateNotification("SomeThing Went Wrong! We Have Sent The Error Code To The Devs!", Color3.fromRGB(206, 67, 67))
                wait(0.5)
                Script.Functions.CreateNotification(Error, Color3.fromRGB(206, 67, 67))
            end
        end
        RS.Heartbeat:Wait()
    end
end))

-- // Fires Every Frame After The Physics Simulation Has Completed.
RS.RenderStepped:Connect(function(DeltaTime)
    local Succes, Error = pcall(function()
        -- // Notification Fade Function And Position Change
    	local Smallest = math.huge
    	for i = 1, #Script.NotifyNote do
    		local v = Script.NotifyNote[i]
    		if v and v.Enabled then
    			Smallest = i < Smallest and i or Smallest
    		else
    			table.remove(Script.NotifyNote, i)
    		end
    	end
    	local Length = #Script.NotifyNote
    	for i = 1, #Script.NotifyNote do
    		local Note = Script.NotifyNote[i]
    		Note:Update(i, Length, DeltaTime)
    		if i <= math.ceil(Length / 10) or Note.Fading then
    			Note:Fade(i, Length, DeltaTime)
    		end
    	end
    end)
    if not Succes then
        if SavedError2 ~= Error then
            SavedError2 = Error
            Script.Functions.CreateNotification("SomeThing Went Wrong! We Have Sent The Error Code To The Devs!", Color3.fromRGB(206, 67, 67))
            wait(0.5)
            Script.Functions.CreateNotification(Error, Color3.fromRGB(206, 67, 67))
        end
    end
end)

-- // The Function For Target Bot, GunSettings
coroutine.resume(coroutine.create(function()
    while true do
        local Succes, Error = pcall(function()
            if Spoof.UniversalCheck.Advanced.Target_Bots and game:GetService("Workspace"):FindFirstChild(Spoof.UniversalCheck.Advanced.Bot_Path) then
                for _, v in pairs(game:GetService("Workspace")[Spoof.UniversalCheck.Advanced.Bot_Path]:GetChildren()) do
                    if not Players:FindFirstChild(v.Name) then
                        local CreatePlayer = Instance.new("Player")
                        CreatePlayer.Name = v.Name
                        CreatePlayer.Character = v
                    else
                        if Players:FindFirstChild(v.Name) then
                            Players[v.Name].Character = v
                        end
                    end
                end
            end
        	if Spoof.Silent.GunSettings.Enabled then
            	local CurrentGun = Script.Functions.GetCurrentWeaponName()
                local WeaponSettings = Spoof.Silent.GunSettings[CurrentGun]
                if WeaponSettings ~= nil then
                    if Spoof.Silent.GunSettings.Methods.Range == false then
                        if Spoof.Silent.GunSettings.Methods.Smoothness and Script.SavedValue.AimAssistSmoothX ~=  WeaponSettings.Smoothness then
                            Spoof.AimAssist.Smoothness_X = WeaponSettings.Smoothness
                            Spoof.AimAssist.Smoothness_Y = WeaponSettings.Smoothness
                            Script.SavedValue.AimAssistSmoothX = WeaponSettings.Smoothness
                            Script.SavedValue.AimAssistSmoothY = WeaponSettings.Smoothness
                        end
                        if Spoof.Silent.GunSettings.Methods.AirSmoothness and Spoof.AimAssist.AirSmoothness_X ~= WeaponSettings.AirSmoothness then
                            Spoof.AimAssist.AirSmoothness_X = WeaponSettings.AirSmoothness
                            Spoof.AimAssist.AirSmoothness_Y = WeaponSettings.AirSmoothness
                        end
                        if Spoof.Silent.GunSettings.Methods.HitChance and Spoof.Silent.Prediction ~= WeaponSettings.HitChance then
                            Spoof.Silent.HitChance = WeaponSettings.HitChance
                        end
                        if Spoof.Silent.GunSettings.Methods.AirHitChance and Spoof.Silent.Prediction ~= WeaponSettings.AirHitChance then
                            Spoof.Silent.AirHitChance = WeaponSettings.AirHitChance
                        end
                        if Spoof.Silent.GunSettings.Methods.Prediction and Spoof.Silent.Prediction ~= WeaponSettings.Prediction then
                            Spoof.Silent.Prediction = WeaponSettings.Prediction
                        end
                        if Spoof.Silent.GunSettings.Methods.Fov and SilentFovRadius.Value ~= WeaponSettings.Fov then
                            if Spoof.Silent.GunSettings.Dynamic.Enabled then
                                local Create = Tween:Create(SilentFovRadius, TweenInfo.new(Spoof.Silent.GunSettings.Dynamic.Time, Enum.EasingStyle[Spoof.Silent.GunSettings.Dynamic.EasingStyle], Enum.EasingDirection[Spoof.Silent.GunSettings.Dynamic.EasingDirection]), {Value = WeaponSettings.Fov})
                                Create:Play()
                                Create.Completed:Wait()
                            else
                                SilentFovRadius.Value = WeaponSettings.Fov
                            end
                        end
                    end
                    if Spoof.Silent.Part == nil then return end
                    if Spoof.Silent.GunSettings.Methods.Range and Script.Functions.Alive(SilentTarget) and Script.Functions.Alive(Client) and SilentTarget.Character:FindFirstChild(Spoof.Silent.Part) then
                        local Magnitude = Script.Functions.GetMagnitudeFromMouse(SilentTarget.Character.HumanoidRootPart)

                        if (Spoof.Silent.ForceLock == false and Script.Drawing.SilentCircle.Radius + 4 > Magnitude) or Spoof.Silent.ForceLock == true then
                            local Magnitude = (SilentTarget.Character.HumanoidRootPart.Position - Client.Character.HumanoidRootPart.Position).Magnitude
                            if Magnitude < Spoof.Silent.GunSettings.Close_Activation then
                                if Spoof.Silent.GunSettings.Methods.Smoothness and Script.SavedValue.AimAssistSmoothX ~=  WeaponSettings.CloseSmoothness then
                                    Spoof.AimAssist.Smoothness_X = WeaponSettings.CloseSmoothness
                                    Spoof.AimAssist.Smoothness_Y = WeaponSettings.CloseSmoothness
                                    Script.SavedValue.AimAssistSmoothX = WeaponSettings.CloseSmoothness
                                    Script.SavedValue.AimAssistSmoothY = WeaponSettings.CloseSmoothness
                                end
                                if Spoof.Silent.GunSettings.Methods.AirSmoothness and Spoof.AimAssist.AirSmoothness_X ~= WeaponSettings.CloseAirSmoothness then
                                    Spoof.AimAssist.AirSmoothness_X = WeaponSettings.CloseAirSmoothness
                                    Spoof.AimAssist.AirSmoothness_Y = WeaponSettings.CloseAirSmoothness
                                end
                                if Spoof.Silent.GunSettings.Methods.HitChance and Spoof.Silent.HitChance ~= WeaponSettings.CloseHitChance then
                                    Spoof.Silent.HitChance = WeaponSettings.CloseHitChance
                                end
                                if Spoof.Silent.GunSettings.Methods.AirHitChance and Spoof.Silent.AirHitChance ~= WeaponSettings.CloseAirHitChance then
                                    Spoof.Silent.AirHitChance = WeaponSettings.CloseAirHitChance
                                end
                                if Spoof.Silent.GunSettings.Methods.Prediction and Spoof.Silent.Prediction ~= WeaponSettings.ClosePrediction then
                                    Spoof.Silent.Prediction = WeaponSettings.ClosePrediction
                                end
                                if Spoof.Silent.GunSettings.Methods.Fov and SilentFovRadius.Value ~= WeaponSettings.CloseFov then
                                    if Spoof.Silent.GunSettings.Dynamic.Enabled then
                                        local Create = Tween:Create(SilentFovRadius, TweenInfo.new(Spoof.Silent.GunSettings.Dynamic.Time, Enum.EasingStyle[Spoof.Silent.GunSettings.Dynamic.EasingStyle], Enum.EasingDirection[Spoof.Silent.GunSettings.Dynamic.EasingDirection]), {Value = WeaponSettings.CloseFov})
                                        Create:Play()
                                        Create.Completed:Wait()
                                    else
                                        SilentFovRadius.Value = WeaponSettings.CloseFov
                                    end
                                end
                            elseif Magnitude < Spoof.Silent.GunSettings.Medium_Activation then
                                if Spoof.Silent.GunSettings.Methods.Smoothness and Script.SavedValue.AimAssistSmoothX ~= WeaponSettings.MedSmoothness then
                                    Spoof.AimAssist.Smoothness_X = WeaponSettings.MedSmoothness
                                    Spoof.AimAssist.Smoothness_Y = WeaponSettings.MedSmoothness
                                    Script.SavedValue.AimAssistSmoothX = WeaponSettings.MedSmoothness
                                    Script.SavedValue.AimAssistSmoothY = WeaponSettings.MedSmoothness
                                end
                                if Spoof.Silent.GunSettings.Methods.AirSmoothness and Spoof.AimAssist.AirSmoothness_X ~= WeaponSettings.MedAirSmoothness then
                                    Spoof.AimAssist.AirSmoothness_X = WeaponSettings.MedAirSmoothness
                                    Spoof.AimAssist.AirSmoothness_Y = WeaponSettings.MedAirSmoothness
                                end
                                if Spoof.Silent.GunSettings.Methods.HitChance and Spoof.Silent.HitChance ~= WeaponSettings.MedHitChance then
                                    Spoof.Silent.HitChance = WeaponSettings.MedHitChance
                                end
                                if Spoof.Silent.GunSettings.Methods.AirHitChance and Spoof.Silent.AirHitChance ~= WeaponSettings.MedAirHitChance then
                                    Spoof.Silent.AirHitChance = WeaponSettings.MedAirHitChance
                                end
                                if Spoof.Silent.GunSettings.Methods.Prediction and Spoof.Silent.Prediction ~= WeaponSettings.MedPrediction then
                                    Spoof.Silent.Prediction = WeaponSettings.ClosePrediction
                                end
                                if Spoof.Silent.GunSettings.Methods.Fov and SilentFovRadius.Value ~= WeaponSettings.MedFov then
                                    if Spoof.Silent.GunSettings.Dynamic.Enabled then
                                        local Create = Tween:Create(SilentFovRadius, TweenInfo.new(Spoof.Silent.GunSettings.Dynamic.Time, Enum.EasingStyle[Spoof.Silent.GunSettings.Dynamic.EasingStyle], Enum.EasingDirection[Spoof.Silent.GunSettings.Dynamic.EasingDirection]), {Value = WeaponSettings.MedFov})
                                        Create:Play()
                                        Create.Completed:Wait()
                                    else
                                        SilentFovRadius.Value = WeaponSettings.MedFov
                                    end
                                end
                            elseif Magnitude < Spoof.Silent.GunSettings.Far_Activation then
                                if Spoof.Silent.GunSettings.Methods.Smoothness and Script.SavedValue.AimAssistSmoothX ~= WeaponSettings.FarSmoothness then
                                    Spoof.AimAssist.Smoothness_X = WeaponSettings.FarSmoothness
                                    Spoof.AimAssist.Smoothness_Y = WeaponSettings.FarSmoothness
                                    Script.SavedValue.AimAssistSmoothX = WeaponSettings.FarSmoothness
                                    Script.SavedValue.AimAssistSmoothY = WeaponSettings.FarSmoothness
                                end
                                if Spoof.Silent.GunSettings.Methods.AirSmoothness and Spoof.AimAssist.AirSmoothness_X ~= WeaponSettings.FarAirSmoothness then
                                    Spoof.AimAssist.AirSmoothness_X = WeaponSettings.FarAirSmoothness
                                    Spoof.AimAssist.AirSmoothness_Y = WeaponSettings.FarAirSmoothness
                                end
                                if Spoof.Silent.GunSettings.Methods.HitChance and Spoof.Silent.HitChance ~= WeaponSettings.FarHitChance then
                                    Spoof.Silent.HitChance = WeaponSettings.FarHitChance
                                end
                                if Spoof.Silent.GunSettings.Methods.AirHitChance and Spoof.Silent.AirHitChance ~= WeaponSettings.FarAirHitChance then
                                    Spoof.Silent.AirHitChance = WeaponSettings.FarAirHitChance
                                end
                                if Spoof.Silent.GunSettings.Methods.Prediction and Spoof.Silent.Prediction ~= WeaponSettings.FarPrediction then
                                    Spoof.Silent.Prediction = WeaponSettings.FarPrediction
                                end
                                if Spoof.Silent.GunSettings.Methods.Fov and SilentFovRadius.Value ~= WeaponSettings.FarFov then
                                    if Spoof.Silent.GunSettings.Dynamic.Enabled then
                                        local Create = Tween:Create(SilentFovRadius, TweenInfo.new(Spoof.Silent.GunSettings.Dynamic.Time, Enum.EasingStyle[Spoof.Silent.GunSettings.Dynamic.EasingStyle], Enum.EasingDirection[Spoof.Silent.GunSettings.Dynamic.EasingDirection]), {Value = WeaponSettings.FarFov})
                                        Create:Play()
                                        Create.Completed:Wait()
                                    else
                                        SilentFovRadius.Value = WeaponSettings.FarFov
                                    end
                                end
                            end
                        end
                    end
                end
            end
        end)
        if not Succes then
            if SavedError3 ~= Error then
                SavedError3 = Error
                Script.Functions.CreateNotification("SomeThing Went Wrong! We Have Sent The Error Code To The Devs!", Color3.fromRGB(206, 67, 67))
                wait(0.5)
                Script.Functions.CreateNotification(Error, Color3.fromRGB(206, 67, 67))
            end
        end
        RS.Heartbeat:Wait()
    end
end))

-- // Checks Everyone In The Server And Puts It In A Table
for _, Plr in pairs(Players:GetPlayers()) do
    coroutine.resume(coroutine.create(function()
        if Plr ~= Client then
            if Client:IsFriendsWith(Plr.UserId) then
                table.insert(Script.Friends, Plr)
            end
            Script.Functions.CheckIfMod(Plr)
            Script.Functions.NewPlayer(Plr)
        end
    end))
end

-- // Checks When Players Joins And Adds Them To A Table
Players.PlayerAdded:Connect(function(Plr)
    coroutine.resume(coroutine.create(function()
        if Plr ~= Client then
            if Client:IsFriendsWith(Plr.UserId) then
                table.insert(Script.Friends, Plr)
            end
            Script.Functions.CheckIfMod(Plr)
            Script.Functions.NewPlayer(Plr)
        end
    end))
end)

-- // Checks If A Player Left And Removes Them From The Table
Players.PlayerRemoving:Connect(function(Plr)
    if table.find(Script.Friends, Plr) then
        table.remove(Script.Friends, FindPlayer)
    end
    if game.PlaceId == 2788229376 then
        Script.Functions.RemoveTarget(Plr)
    end
    if table.find(Script.EspPlayers, Plr) then
        for _, v in pairs(Script.EspPlayers[Plr]) do
            if v ~= nil then
                v:Remove()
            end
        end
        table.remove(Script.EspPlayers, Plr)
    end
end)

-- // The Functions For The Internal Commands. SHITTY
if Spoof.Options.Internal and rconsoleprint and rconsolename then
    local InternalChatCommands = {
        clear = function()
            rconsoleclear()
        end,
        
        set = function(Path, Path2, Value)
            local CurrentPath = Spoof[Path]
            if not CurrentPath or not CurrentPath[Path2] then return rconsoleprint("Error: Coudlnt Find Path\n") end
            CurrentPath[Path2] = Value
            rconsoleprint("> " .. tostring(Path2) .. " Is Now Set To: " .. tostring(Value) .. "\n")
        end,

        set2 = function(Path, Path2, Path3, Value)
            local CurrentPath = Spoof[Path]
            local CurrentPath2 = CurrentPath[Path2]
            if not CurrentPath or not CurrentPath2 or CurrentPath2[Path3] then return rconsoleprint("Error: Coudlnt Find Path\n") end
            CurrentPath2[Path3] = Value
            rconsoleprint("> " .. tostring(Path3) .. " Is Now Set To: " .. tostring(Value) .. "\n")
        end,
        
        getplayers = function()
            for _, v in pairs(Players:GetChildren()) do
                if v ~= Client then
                    rconsoleprint("> " .. tostring(v).."\n")
                end
            end
        end,
        
        getplayersmagnitude = function()
            for _, v in pairs(Players:GetChildren()) do
                if v ~= Client and Script.Functions.Alive(v) and Script.Functions.Alive(Client) then
                    local GetStuds = (Client.Character.HumanoidRootPart.Position - v.Character.HumanoidRootPart.Position).Magnitude
                    rconsoleprint("> " .. tostring(v) .. " Is " .. GetStuds .. " Studs Away From You\n")
                end
            end
        end,
        
        removeesp = function(Plr)
            if table.find(Script.EspPlayers, Players[tostring(Plr)]) then
                for i, v in pairs(Script.EspPlayers[Players[tostring(Plr)]]) do
                    if v then
                        v:Remove()
                        rconsoleprint("> SuccesFully Removed ".. tostring(i) .." \n")
                    else
                        rconsoleprint("Error: Coudlnt Find Player \n")
                    end
                end
                table.remove(Script.EspPlayers, Players[tostring(Plr)])
            end
        end,
        
        addesp = function(Plr)
            if Players[tostring(Plr)] then
                Script.Functions.NewPlayer(Players[tostring(Plr)])
                rconsoleprint("> SuccesFully Added ".. tostring(Plr) .." \n")
            else
                rconsoleprint("Error: Coudlnt Find Player \n")
            end
        end,
        
        teleport = function(Plr)
            if Script.Functions.Alive(Players[Plr]) and Script.Functions.Alive(Client) then
                Client.Character.HumanoidRootPart.CFrame = Players[Plr].Character.HumanoidRootPart.CFrame
                rconsoleprint("> SuccesFully Teleported ".. tostring(Plr) .." \n")
            else
                rconsoleprint("Error: Coudlnt Find Player \n")
            end
        end,

        exec = function(Text)
            loadstring(Text)
        end,
        
        chat = function(Text)
            if Text == ("false") then 
                if getgenv().GetChat then 
                    getgenv().GetChat:Disconnect() 
                end 
            end
            if Text == ("true") then
                local Event = game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents
                getgenv().GetChat = Event.OnMessageDoneFiltering.OnClientEvent:Connect(function(object)
                    rconsoleprint("> " .. string.format("%s : %s \n>", object.FromSpeaker, object.Message or ""))
                end)
            end
        end,
        
        discord = function(Plr)
            if setclipboard then
                setclipboard("discord.gg/Spoof")
            end
            if http_request or request or HttpPost or syn.request then
                local Send = http_request or request or HttpPost or syn.request
                local Table = {
                    ["cmd"] = "INVITE_BROWSER",
                    ["args"] = {["code"] = "Spoof"},
                    ["nonce"] = game:GetService("HttpService"):GenerateGUID(true)
                }
                Send({
                    Url = "http://127.0.0.1:6463/rpc?v=1",
                    Method = "POST",
                    Headers = {
                        ["Content-Type"] = "application/json",
                        ["Origin"] = "https://discord.com"
                    },
                    Body = game:GetService("HttpService"):JSONEncode(Table)
                })
                rconsoleprint("> SuccesFully Invited You To The Discord\n")
            end
        end,
        
        help = function()
            rconsoleprint("\n> List of available ChatCommands:\n\n")
            rconsoleprint("> set(<Path> <Path2> <boolean> Or <string>): Sets The Table To The Value!\n")
            rconsoleprint("> set2(<Path> <Path2> <Path3> <boolean> Or <string>): Sets The Table To The Value!\n")
            rconsoleprint("> addesp(<playername>): WhiteLists The Player Esp\n")
            rconsoleprint("> removeesp(<playername>): Remove The Player Esp\n")
            rconsoleprint("> teleport(<playername>): Teleports You To The Player (RISKY)\n")
            rconsoleprint("> getplayers: prints you an list of the players\n")
            rconsoleprint("> getplayersmagnitude: Prints You An List Of The Players And How Long Away From You\n")
            rconsoleprint("> clear: Clears The Console\n")
            rconsoleprint("> discord: Gets Invites You To The Discord\n")
            rconsoleprint("> exec(<string>): Executes The String\n")
            rconsoleprint("> chat(<boolean>): Shows You People Chatting\n\n")
        end,
    }

    -- // The Main Function For Internal
    coroutine.resume(coroutine.create(function()
        while wait(0.1) do
            rconsolename("Spoof Internal")
            rconsoleprint("> ")
            local line = rconsoleinput()
            local Command, Args = string.match(line, "(%S+)%s*(.*)")

            if Command == nil then
                return
            end

            if type(InternalChatCommands[Command]) ~= ("function") then
                rconsoleprint("\nUnknown Command: " .. Command .. "\n")
            else
                local Splitted = string.split(line, " ")
                if Splitted[2] ~= nil and Splitted[3] ~= nil and Splitted[4] ~= nil and Splitted[5] ~= nil then
                    if Splitted[5] == ("false") then 
                        Splitted[5] = false
                    elseif Splitted[5] == ("true") then 
                        Splitted[5] = true
                    end

                    local Succes, Error = pcall(InternalChatCommands[Command], Splitted[2], Splitted[3], Splitted[4], Splitted[5])
                    if not Succes then
                        rconsoleprint("\nError: " .. Error .. "\n")
                    end
                elseif Splitted[2] ~= nil and Splitted[3] ~= nil and Splitted[4] ~= nil then
                    if Splitted[4] == ("false") then 
                        Splitted[4] = false
                    elseif Splitted[4] == ("true") then 
                        Splitted[4] = true
                    end

                    local Succes, Error = pcall(InternalChatCommands[Command], Splitted[2], Splitted[3], Splitted[4])
                    if not Succes then
                        rconsoleprint("\nError: " .. Error .. "\n")
                    end
                else
                    if Command ~= ("set") or Command ~= ("set2") then
                        local Succes, Error = pcall(InternalChatCommands[Command], Args)
                        if not Succes then
                            rconsoleprint("\nError: " .. Error .. "\n")
                        end

                        rconsoleprint("\nError: Command Error\n")
                    end
                end
            end
        end
    end))
end

-- // Sends Information For Basic Stuff
if Spoof.Options.GetInformation then
    if GetTime then
        Script.Functions.CreateNotification("Loaded In: " .. string.format("%.".."4".."f", os.clock() - GetTime) .. " Seconds", Color3.fromRGB(206, 67, 67))
    end
end
